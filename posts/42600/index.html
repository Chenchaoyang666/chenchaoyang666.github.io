<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>web学习路线汇总篇 | CCY's Blog</title><meta name="description" content="一、简历简历在找工作过程中是非常非常重要的，无论你是什么途径去面试的，面试你的人一定会看你的简历。 推荐阅读： 如何写「前端简历」，能敲开字节跳动的大门？ 一份优秀的前端开发工程师简历是怎么样的？ 1、重点 简历就像高考作文——阅卷时间非常短。 内容要简洁。 直击重点，表现出自己的优势（只要是符合招人单位要求的都是优势，不是别人不会的你会才叫优势）。  2、简历包含的内容 个人信息。 专业技能。"><meta name="keywords" content="JavaScrip,Css,Html,面试,Http"><meta name="author" content="Chen cy"><meta name="copyright" content="Chen cy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/CDN/other/4.jpg"><link rel="canonical" href="https://www.chency.top/posts/42600/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="web学习路线汇总篇"><meta property="og:url" content="https://www.chency.top/posts/42600/"><meta property="og:site_name" content="CCY's Blog"><meta property="og:description" content="一、简历简历在找工作过程中是非常非常重要的，无论你是什么途径去面试的，面试你的人一定会看你的简历。 推荐阅读： 如何写「前端简历」，能敲开字节跳动的大门？ 一份优秀的前端开发工程师简历是怎么样的？ 1、重点 简历就像高考作文——阅卷时间非常短。 内容要简洁。 直击重点，表现出自己的优势（只要是符合招人单位要求的都是优势，不是别人不会的你会才叫优势）。  2、简历包含的内容 个人信息。 专业技能。"><meta property="og:image" content="https://www.chency.top/CDN/wallpaper/cover_12.jpg"><meta property="article:published_time" content="2023-12-31T04:13:05.468Z"><meta property="article:modified_time" content="2023-12-31T04:13:05.468Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="async/await使用对比" href="https://www.chency.top/posts/26266/"><link rel="next" title="Vue 特性集合" href="https://www.chency.top/posts/56620/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-12-31 12:13:05'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/chency.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/CDN/other/4.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">21</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-book"></i><span> 找文章</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li><li><a class="site-page" href="/box/"><i class="fa-fw fab fa-xbox"></i><span> 聚宝盒</span></a></li><li><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></li><li><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 小伙伴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、简历"><span class="toc-number">1.</span> <span class="toc-text">一、简历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、重点"><span class="toc-number">1.1.</span> <span class="toc-text">1、重点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、简历包含的内容"><span class="toc-number">1.2.</span> <span class="toc-text">2、简历包含的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-基本信息"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 基本信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-专业技能"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 专业技能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-工作经历"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 工作经历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-项目经历"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 项目经历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-社区贡献"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 社区贡献</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、注意事项"><span class="toc-number">1.3.</span> <span class="toc-text">3、注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、面试前准备"><span class="toc-number">1.4.</span> <span class="toc-text">4、面试前准备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、HTML-CSS-面试题"><span class="toc-number">2.</span> <span class="toc-text">二、HTML+CSS 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、HTML-面试题"><span class="toc-number">2.1.</span> <span class="toc-text">1、HTML 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-如何理解-HTML-语义化？"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 如何理解 HTML 语义化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-script-标签中-defer-和-async-的区别？"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 script 标签中 defer 和 async 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-从浏览器地址栏输入-url-到请求返回发生了什么"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 从浏览器地址栏输入 url 到请求返回发生了什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、CSS-面试题"><span class="toc-number">2.2.</span> <span class="toc-text">2、CSS 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-盒模型介绍"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 盒模型介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-css-选择器和优先级"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 css 选择器和优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-重排（reflow）和重绘（repaint）的理解"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 重排（reflow）和重绘（repaint）的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-对-BFC-的理解"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4 对 BFC 的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-实现两栏布局（左侧固定-右侧自适应布局）"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.5 实现两栏布局（左侧固定 + 右侧自适应布局）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-实现圣杯布局和双飞翼布局（经典三分栏布局）"><span class="toc-number">2.2.6.</span> <span class="toc-text">2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-水平垂直居中多种实现方式"><span class="toc-number">2.2.7.</span> <span class="toc-text">2.7 水平垂直居中多种实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-flex-布局"><span class="toc-number">2.2.8.</span> <span class="toc-text">2.8 flex 布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-line-height-如何继承？"><span class="toc-number">2.2.9.</span> <span class="toc-text">2.9 line-height 如何继承？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、js-基础"><span class="toc-number">3.</span> <span class="toc-text">三、js 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、数据类型"><span class="toc-number">3.1.</span> <span class="toc-text">1、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-基本的数据类型介绍，及值类型和引用类型的理解"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 基本的数据类型介绍，及值类型和引用类型的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-数据类型的判断"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 数据类型的判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-手写深拷贝"><span class="toc-number">3.1.3.</span> <span class="toc-text">1.3 手写深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-根据-0-1-0-2-0-3，讲讲-IEEE-754-，如何让其相等？"><span class="toc-number">3.1.4.</span> <span class="toc-text">1.4 根据 0.1+0.2 ! &#x3D;&#x3D; 0.3，讲讲 IEEE 754 ，如何让其相等？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、-原型和原型链"><span class="toc-number">3.2.</span> <span class="toc-text">2、 原型和原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、-作用域与作用域链"><span class="toc-number">3.3.</span> <span class="toc-text">3、 作用域与作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、-执行上下文"><span class="toc-number">3.4.</span> <span class="toc-text">4、 执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、-闭包"><span class="toc-number">3.5.</span> <span class="toc-text">5、 闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、-call、apply、bind-实现"><span class="toc-number">3.6.</span> <span class="toc-text">6、 call、apply、bind 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、-new-实现"><span class="toc-number">3.7.</span> <span class="toc-text">7、 new 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、-异步"><span class="toc-number">3.8.</span> <span class="toc-text">8、 异步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-event-loop、宏任务和微任务"><span class="toc-number">3.8.1.</span> <span class="toc-text">8.1 event loop、宏任务和微任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-Promise"><span class="toc-number">3.8.2.</span> <span class="toc-text">8.2 Promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-async-await-和-Promise-的关系"><span class="toc-number">3.8.3.</span> <span class="toc-text">8.3 async&#x2F;await 和 Promise 的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、-浏览器的垃圾回收机制"><span class="toc-number">3.9.</span> <span class="toc-text">9、 浏览器的垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、-实现一个-EventMitter-类"><span class="toc-number">3.10.</span> <span class="toc-text">10、 实现一个 EventMitter 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、web-存储"><span class="toc-number">4.</span> <span class="toc-text">四、web 存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、cookie"><span class="toc-number">4.1.</span> <span class="toc-text">1、cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、localStorage-和-sessionStorage"><span class="toc-number">4.2.</span> <span class="toc-text">2、localStorage 和 sessionStorage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、Http"><span class="toc-number">5.</span> <span class="toc-text">五、Http</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、http-状态码"><span class="toc-number">5.1.</span> <span class="toc-text">1、http 状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-状态码分类"><span class="toc-number">5.1.1.</span> <span class="toc-text">1.1 状态码分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-常见状态码"><span class="toc-number">5.1.2.</span> <span class="toc-text">1.2 常见状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-关于协议和规范"><span class="toc-number">5.1.3.</span> <span class="toc-text">1.3 关于协议和规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、http-缓存"><span class="toc-number">5.2.</span> <span class="toc-text">2、http 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-关于缓存"><span class="toc-number">5.2.1.</span> <span class="toc-text">4.1 关于缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-强制缓存"><span class="toc-number">5.2.2.</span> <span class="toc-text">4.2 强制缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-协商缓存（对比缓存）"><span class="toc-number">5.2.3.</span> <span class="toc-text">4.3 协商缓存（对比缓存）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-综述"><span class="toc-number">5.2.4.</span> <span class="toc-text">4.4 综述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-三种刷新操作对-http-缓存的影响"><span class="toc-number">5.2.5.</span> <span class="toc-text">4.4 三种刷新操作对 http 缓存的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-面试"><span class="toc-number">5.3.</span> <span class="toc-text">3. 面试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、vue相关"><span class="toc-number">6.</span> <span class="toc-text">六、vue相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、webpack"><span class="toc-number">7.</span> <span class="toc-text">七、webpack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、模块化"><span class="toc-number">8.</span> <span class="toc-text">八、模块化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、性能优化"><span class="toc-number">9.</span> <span class="toc-text">九、性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、常见手写"><span class="toc-number">10.</span> <span class="toc-text">十、常见手写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、防抖"><span class="toc-number">10.1.</span> <span class="toc-text">1、防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、节流"><span class="toc-number">10.2.</span> <span class="toc-text">2、节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、快速排序"><span class="toc-number">10.3.</span> <span class="toc-text">3、快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、instanceof"><span class="toc-number">10.4.</span> <span class="toc-text">4、instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、数组扁平化"><span class="toc-number">10.5.</span> <span class="toc-text">5、数组扁平化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、手写-reduce"><span class="toc-number">10.6.</span> <span class="toc-text">6、手写 reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、带并发的异步调度器-Scheduler"><span class="toc-number">10.7.</span> <span class="toc-text">7、带并发的异步调度器 Scheduler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、去重"><span class="toc-number">10.8.</span> <span class="toc-text">8、去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一、其它"><span class="toc-number">11.</span> <span class="toc-text">十一、其它</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二、算法"><span class="toc-number">12.</span> <span class="toc-text">十二、算法</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(/CDN/wallpaper/cover_12.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">CCY's Blog</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-book"></i><span> 找文章</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li><li><a class="site-page" href="/box/"><i class="fa-fw fab fa-xbox"></i><span> 聚宝盒</span></a></li><li><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></li><li><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 小伙伴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">web学习路线汇总篇</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2023-12-31 12:13:05"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2023-12-31</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2023-12-31 12:13:05"><i class="fas fa-history fa-fw"></i> 更新于 2023-12-31</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">12.2k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 44 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="一、简历"><a href="#一、简历" class="headerlink" title="一、简历"></a>一、简历</h2><p>简历在找工作过程中是非常非常重要的，无论你是什么途径去面试的，面试你的人一定会看你的简历。</p>
<p>推荐阅读：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fpy_HLqOjNdL4l0CZHjMwqw" title="https://mp.weixin.qq.com/s/py_HLqOjNdL4l0CZHjMwqw">如何写「前端简历」，能敲开字节跳动的大门？</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F23150301%2Fanswer%2F1229870117" title="https://www.zhihu.com/question/23150301/answer/1229870117">一份优秀的前端开发工程师简历是怎么样的？</a></p>
<h3 id="1、重点"><a href="#1、重点" class="headerlink" title="1、重点"></a>1、重点</h3><ul>
<li>简历就像高考作文——阅卷时间非常短。</li>
<li>内容要简洁。</li>
<li>直击重点，表现出自己的优势（只要是符合招人单位要求的都是优势，不是别人不会的你会才叫优势）。</li>
</ul>
<h3 id="2、简历包含的内容"><a href="#2、简历包含的内容" class="headerlink" title="2、简历包含的内容"></a>2、简历包含的内容</h3><ul>
<li>个人信息。</li>
<li>专业技能。</li>
<li>工作经历。</li>
<li>项目经历。</li>
<li>社区贡献。</li>
</ul>
<h4 id="2-1-基本信息"><a href="#2-1-基本信息" class="headerlink" title="2.1 基本信息"></a>2.1 基本信息</h4><ul>
<li>必备：姓名 电话 邮箱。</li>
<li>年龄（最好写上，在这个行业年龄还是比较重要的），学历（写好是哪一届）。</li>
<li>头像无所谓（好看就放上呗）。</li>
<li>可以放 github 链接，前提是有内容。</li>
</ul>
<h4 id="2-2-专业技能"><a href="#2-2-专业技能" class="headerlink" title="2.2 专业技能"></a>2.2 专业技能</h4><ul>
<li>表现出自己的核心竞争力（只要是符合招人单位要求的都是优势）。</li>
<li>内容不要太多，3、5 条即可。</li>
<li>太基础的不要写，例如会用 vscode、lodash。</li>
</ul>
<h4 id="2-3-工作经历"><a href="#2-3-工作经历" class="headerlink" title="2.3 工作经历"></a>2.3 工作经历</h4><ul>
<li>如实写。</li>
<li>写明公司，职位，入职离职时间即可，多写无益。</li>
<li>如果有空窗期，如实写明即可。</li>
</ul>
<h4 id="2-4-项目经历"><a href="#2-4-项目经历" class="headerlink" title="2.4 项目经历"></a>2.4 项目经历</h4><ul>
<li>写 2-4 个具有说服力的项目（不要什么项目都写，没用）。</li>
<li>项目名称，项目描述，技术栈，个人角色。</li>
</ul>
<h4 id="2-5-社区贡献"><a href="#2-5-社区贡献" class="headerlink" title="2.5 社区贡献"></a>2.5 社区贡献</h4><ul>
<li>有博客或者开源作品，会让你更有竞争力。</li>
<li>切记：需要真的有内容，不可临时抱佛脚。</li>
</ul>
<h3 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h3><ul>
<li>界面不能太花哨，简洁明了即可。</li>
<li>注意用词，“精通”“熟练”等慎用，可用“熟悉”。</li>
<li>不可造假，会被拉入黑名单。</li>
</ul>
<h3 id="4、面试前准备"><a href="#4、面试前准备" class="headerlink" title="4、面试前准备"></a>4、面试前准备</h3><ul>
<li>看 JD，是否需要临时准备一下。</li>
<li>打印纸质简历，带着纸和笔（增加好印象）。</li>
<li>最好带着自己电脑，现场可能手写代码（带一个帆布包最适合，又优雅又方便）。</li>
<li>要有时间观念，如果迟到或者推迟，要提前说。</li>
<li>衣着适当，不用正装，也不要太随意。</li>
<li>为何离职？—— 不要吐槽前东家，说自己的原因（想找一个更好的发展平台等）。</li>
<li>能加班吗？—— 能！除非你特别自信，能找到其他机会。</li>
<li>不要挑战面试官，即便他错了（面试一定要保证愉快）。</li>
<li>遇到不会的问题，要表现出自己积极的一面（不好意思哈，确实是我的知识盲区，可以跟我说下 xxx 吗，我回去研究一下）。</li>
</ul>
<h2 id="二、HTML-CSS-面试题"><a href="#二、HTML-CSS-面试题" class="headerlink" title="二、HTML+CSS 面试题"></a>二、HTML+CSS 面试题</h2><p>HTML 和 CSS 面试题答不出来基本可以回去了。</p>
<h3 id="1、HTML-面试题"><a href="#1、HTML-面试题" class="headerlink" title="1、HTML 面试题"></a>1、HTML 面试题</h3><p>以下是针对 HTML 相关的面试题，一般来说这地方不会出太多题，面试官也不愿意花太多时间在这上面。</p>
<h4 id="1-1-如何理解-HTML-语义化？"><a href="#1-1-如何理解-HTML-语义化？" class="headerlink" title="1.1 如何理解 HTML 语义化？"></a>1.1 如何理解 HTML 语义化？</h4><ul>
<li>让人更容易读懂（增加代码可读性）。</li>
<li>让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。</li>
<li>在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。</li>
</ul>
<h4 id="1-2-script-标签中-defer-和-async-的区别？"><a href="#1-2-script-标签中-defer-和-async-的区别？" class="headerlink" title="1.2 script 标签中 defer 和 async 的区别？"></a>1.2 script 标签中 defer 和 async 的区别？</h4><ul>
<li><code>script</code> ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</li>
<li><code>async script</code> ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</li>
<li><code>defer script</code>：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</li>
</ul>
<p>下图清晰地展示了三种 <code>script</code> 的过程：<br><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea091aed8364b88a653a13c4845a824~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<blockquote>
<p>推荐文章：</p>
<ul>
<li><a href="https://juejin.cn/post/6894629999215640583" target="_blank" rel="noopener" title="https://juejin.cn/post/6894629999215640583">图解 script 标签中的 async 和 defer 属性</a></li>
</ul>
</blockquote>
<h4 id="1-3-从浏览器地址栏输入-url-到请求返回发生了什么"><a href="#1-3-从浏览器地址栏输入-url-到请求返回发生了什么" class="headerlink" title="1.3 从浏览器地址栏输入 url 到请求返回发生了什么"></a>1.3 从浏览器地址栏输入 url 到请求返回发生了什么</h4><p>先阅读这篇科普性质的：<a href="https://juejin.cn/post/6844903784229896199" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903784229896199">从 URL 输入到页面展现到底发生什么？</a><br>先阅读篇文章：<a href="https://juejin.cn/post/6935232082482298911" target="_blank" rel="noopener" title="https://juejin.cn/post/6935232082482298911">从输入 URL 开始建立前端知识体系</a>。</p>
<ol>
<li>输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。</li>
</ol>
<ul>
<li>强缓存。</li>
<li>协商缓存。</li>
</ul>
<ol start="2">
<li>DNS 域名解析。（<a href="https://juejin.cn/post/6990344840181940261" target="_blank" rel="noopener" title="https://juejin.cn/post/6990344840181940261">字节面试被虐后，是时候搞懂 DNS 了</a>）</li>
<li>TCP 连接。<blockquote>
<p>总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点<strong>可靠传输</strong>决定的。客户端和服务端要进行可靠传输，那么就需要 <strong>确认双方的接收和发送能力</strong> 。第一次握手可以确认客服端的 <strong>发送能力</strong> ，第二次握手，确认了服务端的 <strong>发送能力和接收能力</strong> ，所以第三次握手才可以确认客户端的 <strong>接收能力</strong> 。不然容易出现丢包的现象。</p>
</blockquote>
</li>
<li>http 请求。</li>
<li>服务器处理请求并返回 HTTP 报文。</li>
<li>浏览器渲染页面。</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77972f24d69243bb93679f155f305095~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<ol start="7">
<li>断开 TCP 连接。</li>
</ol>
<h3 id="2、CSS-面试题"><a href="#2、CSS-面试题" class="headerlink" title="2、CSS 面试题"></a>2、CSS 面试题</h3><p>以下是针对 CSS 相关的面试题，这些题答不出来会给人非常不好的技术印象。</p>
<h4 id="2-1-盒模型介绍"><a href="#2-1-盒模型介绍" class="headerlink" title="2.1 盒模型介绍"></a>2.1 盒模型介绍</h4><p>CSS3 中的盒模型有以下两种： <strong>标准盒模型</strong> 、 <strong>IE（替代）盒模型</strong> 。</p>
<p>两种盒子模型都是由 <code>content + padding + border + margin</code> 构成，其大小都是由 <code>content + padding + border</code> 决定的，但是盒子内容宽/高度（即 <code>width/height</code>）的计算范围根据盒模型的不同会有所不同：</p>
<ul>
<li>标准盒模型：只包含 <code>content</code> 。</li>
<li>IE（替代）盒模型：<code>content + padding + border</code> 。</li>
</ul>
<p>可以通过 <code>box-sizing</code> 来改变元素的盒模型：</p>
<ul>
<li><code>box-sizing: content-box</code> ：标准盒模型（默认值）。</li>
<li><code>box-sizing: border-box</code> ：IE（替代）盒模型。</li>
</ul>
<h4 id="2-2-css-选择器和优先级"><a href="#2-2-css-选择器和优先级" class="headerlink" title="2.2 css 选择器和优先级"></a>2.2 css 选择器和优先级</h4><p>首先我们要知道有哪些选择器：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FLearn%2FCSS%2FBuilding_blocks%2FSelectors%23%25E9%2580%2589%25E6%258B%25A9%25E5%2599%25A8%25E5%258F%2582%25E8%2580%2583%25E8%25A1%25A8" title="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors#%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%82%E8%80%83%E8%A1%A8">选择器参考表</a>。</p>
<p>常规来说，大家都知道样式的优先级一般为 <code>!important &gt; style &gt; id &gt; class</code> ，但是涉及多类选择器作用于同一个元素时候怎么判断优先级呢？相信我，你在改一些第三方库（比如 antd 😂）样式时，理解这个会帮助很大！</p>
<p>这篇文章写的非常清晰易懂，强烈推荐，看完之后就没啥问题了：<a href="https://juejin.cn/post/6844903709772611592" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903709772611592">深入理解 CSS 选择器优先级</a>。</p>
<blockquote>
<p>上述文章中核心内容：<br>优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p>
<ul>
<li>如果存在内联样式，那么 <code>A = 1</code>，否则 <code>A = 0</code> ；</li>
<li>B 的值等于 <code>ID选择器（#id）</code> 出现的次数；</li>
<li>C 的值等于 <code>类选择器（.class）</code> 和 <code>属性选择器（a[href=&quot;https://example.org&quot;]）</code> 和 <code>伪类（:first-child）</code> 出现的总次数；</li>
<li>D 的值等于 <code>标签选择器（h1,a,div）</code> 和 <code>伪元素（::before,::after）</code> 出现的总次数。</li>
</ul>
</blockquote>
<blockquote>
<p>从左至右比较，如果是样式优先级相等，取后面出现的样式。</p>
</blockquote>
<h4 id="2-3-重排（reflow）和重绘（repaint）的理解"><a href="#2-3-重排（reflow）和重绘（repaint）的理解" class="headerlink" title="2.3 重排（reflow）和重绘（repaint）的理解"></a>2.3 重排（reflow）和重绘（repaint）的理解</h4><p>简单地总结下两者的概念：</p>
<ul>
<li>重排：无论通过什么方式影响了元素的 <strong>几何信息</strong> (元素在视口内的位置和尺寸大小)，浏览器需要<strong>重新计算</strong>元素在视口内的几何属性，这个过程叫做重排。</li>
<li>重绘：通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的 <strong>实际像素</strong> ，这个阶段就叫做重绘。</li>
</ul>
<p>如何减少重排和重绘？</p>
<ul>
<li><strong>最小化重绘和重排</strong> ，比如样式集中改变，使用添加新样式类名 <code>.class</code> 或 <code>cssText</code> 。</li>
<li><strong>批量操作 DOM</strong> ，比如读取某元素 <code>offsetWidth</code> 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。</li>
<li><strong>使用 **`</strong>absolute<strong>`</strong> 或 <strong>`</strong>fixed<strong>`</strong> 使元素脱离文档流** ，这在制作复杂的动画时对性能的影响比较明显。</li>
<li><strong>开启 GPU 加速</strong> ，利用 css 属性 <code>transform</code> 、<code>will-change</code> 等，比如改变元素位置，我们使用 <code>translate</code> 会比使用绝对定位改变其 <code>left</code> 、<code>top</code> 等来的高效，因为它不会触发重排或重绘，<code>transform</code> 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。</li>
</ul>
<p>这里推荐<strong>腾讯 IVWEB 团队</strong>的这篇文章：<a href="https://juejin.cn/post/6844903779700047885" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903779700047885">你真的了解回流和重绘吗</a>，好好认真看完，面试应该没问题的。</p>
<h4 id="2-4-对-BFC-的理解"><a href="#2-4-对-BFC-的理解" class="headerlink" title="2.4 对 BFC 的理解"></a>2.4 对 BFC 的理解</h4><p>BFC 即块级格式上下文，根据盒模型可知，每个元素都被定义为一个矩形盒子，然而盒子的布局会受到<strong>尺寸，定位，盒子的子元素或兄弟元素，视口的尺寸</strong>等因素决定，所以这里有一个浏览器计算的过程，计算的规则就是由一个叫做<strong>视觉格式化模型</strong>的东西所定义的，BFC 就是来自这个概念，它是 CSS 视觉渲染的一部分， <strong>用于决定块级盒的布局及浮动相互影响范围的一个区域</strong> 。</p>
<p>BFC 具有一些特性：</p>
<ol>
<li>块级元素会在垂直方向一个接一个的排列，和文档流的排列方式一致。</li>
<li>在 BFC 中上下相邻的两个容器的 <code>margin</code>  会重叠，创建新的 BFC 可以避免外边距重叠。</li>
<li>计算 BFC 的高度时，需要计算浮动元素的高度。</li>
<li>BFC 区域不会与浮动的容器发生重叠。</li>
<li>BFC 是独立的容器，容器内部元素不会影响外部元素。</li>
<li>每个元素的左 <code>margin</code>  值和容器的左 <code>border</code>  相接触。</li>
</ol>
<p>利用这些特性，我们可以解决以下问题：</p>
<ul>
<li>利用 <code>4</code>  和 <code>6</code> ，我们可以实现三栏（或两栏）自适应布局。</li>
<li>利用 <code>2</code> ，我们可以避免 <code>margin</code>  重叠问题。</li>
<li>利用 <code>3</code> ，我们可以避免高度塌陷。</li>
</ul>
<p>创建 BFC 的方式：</p>
<ul>
<li>绝对定位元素（<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code> ）。</li>
<li>行内块元素，即 <code>display</code> 为 <code>inline-block</code> 。</li>
<li><code>overflow</code> 的值不为 <code>visible</code> 。</li>
</ul>
<p>推荐文章：<a href="https://juejin.cn/post/6960866014384881671" target="_blank" rel="noopener" title="https://juejin.cn/post/6960866014384881671">可能是最好的 BFC 解析了…</a></p>
<h4 id="2-5-实现两栏布局（左侧固定-右侧自适应布局）"><a href="#2-5-实现两栏布局（左侧固定-右侧自适应布局）" class="headerlink" title="2.5 实现两栏布局（左侧固定 + 右侧自适应布局）"></a>2.5 实现两栏布局（左侧固定 + 右侧自适应布局）</h4><p>现在有以下 DOM 结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 <code>margin-left</code> 设为固定宽度 。注意，因为右边元素的 <code>width</code> 默认为 <code>auto</code> ，所以会自动撑满父元素。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightcoral;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightseagreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 <code>overflow: hidden;</code> 这样右边就触发了 <code>BFC</code> ，<code>BFC</code> 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightcoral;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightseagreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>利用 <code>flex</code> 布局，左边元素固定宽度，右边的元素设置 <code>flex: 1</code> 。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightcoral;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightseagreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>利用绝对定位，父级元素设为相对定位。左边元素 <code>absolute</code>  定位，宽度固定。右边元素的 <code>margin-left</code>  的值设为左边元素的宽度值。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightcoral;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightseagreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>利用绝对定位，父级元素设为相对定位。左边元素宽度固定，右边元素 <code>absolute</code>  定位， <code>left</code>  为宽度大小，其余方向定位为 <code>0</code> 。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightcoral;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightseagreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-实现圣杯布局和双飞翼布局（经典三分栏布局）"><a href="#2-6-实现圣杯布局和双飞翼布局（经典三分栏布局）" class="headerlink" title="2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）"></a>2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）</h4><p>圣杯布局和双飞翼布局的目的：</p>
<ul>
<li>三栏布局，中间一栏最先加载和渲染（ <strong>内容最重要，这就是为什么还需要了解这种布局的原因</strong> ）。</li>
<li>两侧内容固定，中间内容随着宽度自适应。</li>
<li>一般用于 PC 网页。</li>
</ul>
<p>圣杯布局和双飞翼布局的技术总结：</p>
<ul>
<li>使用 <code>float</code>  布局。</li>
<li>两侧使用 <code>margin</code> 负值，以便和中间内容横向重叠。</li>
<li>防止中间内容被两侧覆盖，圣杯布局用 <code>padding</code> ，双飞翼布局用 <code>margin</code> 。</li>
</ul>
<p><strong>圣杯布局：</strong><br>HTML 结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>我是中间<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>我是左边<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>我是右边<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#container</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightcoral;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightcyan;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双飞翼布局：</strong><br>HTML 结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main-wrap"</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.float</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightpink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">190px</span> <span class="number">0</span> <span class="number">190px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightsalmon;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightskyblue;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips：上述代码中 <code>margin-left: -100%</code>  相对的是父元素的 <code>content</code>  宽度，即不包含 <code>paddig</code> 、 <code>border</code>  的宽度。</p>
<p>其实以上问题需要掌握 <strong>margin 负值问题</strong> 即可很好理解。</p>
<h4 id="2-7-水平垂直居中多种实现方式"><a href="#2-7-水平垂直居中多种实现方式" class="headerlink" title="2.7 水平垂直居中多种实现方式"></a>2.7 水平垂直居中多种实现方式</h4><ol>
<li>利用绝对定位，设置 <code>left: 50%</code>  和 <code>top: 50%</code>  现将子元素左上角移到父元素中心位置，然后再通过 <code>translate</code>  来调整子元素的中心点到父元素的中心。该方法可以 <strong>不定宽高</strong> 。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用绝对定位，子元素所有方向都为 <code>0</code> ，将 <code>margin</code>  设置为 <code>auto</code> ，由于宽高固定，对应方向实现平分，该方法必须 <strong>盒子有宽高</strong> 。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>利用绝对定位，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>margin-left</code>  和 <code>margin-top</code>  以子元素自己的一半宽高进行负值赋值。该方法 <strong>必须定宽高</strong> 。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>利用 <code>flex</code> ，最经典最方便的一种了，不用解释，定不定宽高无所谓的。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实还有很多方法，比如 <code>display: grid</code>  或 <code>display: table-cell</code>  来做，有兴趣点击下面这篇文章可以了解下：</p>
<p><a href="https://juejin.cn/post/6844903982960214029" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903982960214029">面试官：你能实现多少种水平垂直居中的布局（定宽高和不定宽高）</a>。</p>
<h4 id="2-8-flex-布局"><a href="#2-8-flex-布局" class="headerlink" title="2.8 flex 布局"></a>2.8 flex 布局</h4><p>这一块内容看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-grammar.html" title="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程</a> 就够了。</p>
<p>这里有个小问题，很多时候我们会用到 <code>flex: 1</code> ，它具体包含了以下的意思：</p>
<ul>
<li><code>flex-grow: 1</code> ：该属性默认为 <code>0</code> ，如果存在剩余空间，元素也不放大。设置为 <code>1</code>  代表会放大。</li>
<li><code>flex-shrink: 1</code> ：该属性默认为 <code>1</code> ，如果空间不足，元素缩小。</li>
<li><code>flex-basis: 0%</code> ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来<strong>计算是否有多余空间</strong>的。默认值为 <code>auto</code> ，即项目本身大小。设置为 <code>0%</code>  之后，因为有 <code>flex-grow</code>  和 <code>flex-shrink</code>  的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 <code>flex-basis</code>  设为 <code>auto</code>  的话，其本身大小将会是 <code>0</code> 。</li>
</ul>
<h4 id="2-9-line-height-如何继承？"><a href="#2-9-line-height-如何继承？" class="headerlink" title="2.9 line-height 如何继承？"></a>2.9 line-height 如何继承？</h4><ul>
<li>父元素的 <code>line-height</code> 写了 <strong>具体数值</strong> ，比如 <code>30px</code>，则子元素 <code>line-height</code> 继承该值。</li>
<li>父元素的 <code>line-height</code> 写了 <strong>比例</strong> ，比如 <code>1.5 或 2</code>，则子元素 <code>line-height</code> 也是继承该比例。</li>
<li>父元素的 <code>line-height</code> 写了 <strong>百分比</strong> ，比如 <code>200%</code>，则子元素 <code>line-height</code> 继承的是父元素 <code>font-size * 200%</code> 计算出来的值。</li>
</ul>
<h2 id="三、js-基础"><a href="#三、js-基础" class="headerlink" title="三、js 基础"></a>三、js 基础</h2><p>js 的考察其实来回就那些东西，不过就我自己而已学习的时候理解是真的理解了，但是忘也确实会忘（大家都说理解了一定不会忘，但是要答全的话还是需要理解+背）。</p>
<h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3><p>以下是比较重要的几个 js 变量要掌握的点。</p>
<h4 id="1-1-基本的数据类型介绍，及值类型和引用类型的理解"><a href="#1-1-基本的数据类型介绍，及值类型和引用类型的理解" class="headerlink" title="1.1 基本的数据类型介绍，及值类型和引用类型的理解"></a>1.1 基本的数据类型介绍，及值类型和引用类型的理解</h4><p>在 JS 中共有 <code>8</code>  种基础的数据类型，分别为： <code>Undefined</code> 、 <code>Null</code> 、 <code>Boolean</code> 、 <code>Number</code> 、 <code>String</code> 、 <code>Object</code> 、 <code>Symbol</code> 、 <code>BigInt</code> 。</p>
<p>其中 <code>Symbol</code>  和 <code>BigInt</code>  是 ES6 新增的数据类型，可能会被单独问：</p>
<ul>
<li>Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。</li>
<li>BigInt 可以表示任意大小的整数。</li>
</ul>
<p><strong>值类型的赋值变动过程如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">a = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55df6cb63d3346be9ec1f572a1514853~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片 1.png"><br>值类型是直接存储在<strong>栈（stack）</strong>中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p>
<p><strong>引用类型的赋值变动过程如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b.age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.age); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56c5c43d1c584ed4b8e4cce8855bab52~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片 2.png"><br>引用类型存储在<strong>堆（heap）</strong>中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；</p>
<h4 id="1-2-数据类型的判断"><a href="#1-2-数据类型的判断" class="headerlink" title="1.2 数据类型的判断"></a>1.2 数据类型的判断</h4><ul>
<li><strong>typeof</strong> ：能判断所有 <strong>值类型，函数</strong> 。不可对 <strong>null、对象、数组</strong>进行精确判断，因为都返回 <code>object</code> 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"str"</span>); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">"foo"</span>)); <span class="comment">// symbol</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2172141653n</span>); <span class="comment">// bigint</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// function</span></span><br><span class="line"><span class="comment">// 不能判别</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>instanceof</strong> ：能判断<strong>对象</strong>类型，不能判断基本数据类型， <strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong> 。比如考虑以下代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vortesnail = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(vortesnail <span class="keyword">instanceof</span> People); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(vortesnail <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>其实现就是顺着<strong>原型链</strong>去找，如果能找到对应的 <code>Xxxxx.prototype</code>  即为 <code>true</code> 。比如这里的 <code>vortesnail</code>  作为实例，顺着原型链能找到 <code>Student.prototype</code>  及 <code>People.prototype</code> ，所以都为 <code>true</code> 。</p>
<ul>
<li><strong>Object.prototype.toString.call()</strong> ：所有原始数据类型都是能判断的，还有 <strong>Error 对象，Date 对象</strong>等。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">2</span>); <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">""</span>); <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>); <span class="comment">// "[object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>); <span class="comment">// "[object Math]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;); <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// "[object Function]"</span></span><br></pre></td></tr></table></figure>

<p>在面试中有一个经常被问的问题就是：如何判断变量是否为数组？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(arr); <span class="comment">// true</span></span><br><span class="line">arr.__proto__ === <span class="built_in">Array</span>.prototype; <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">// "[object Array]"</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-手写深拷贝"><a href="#1-3-手写深拷贝" class="headerlink" title="1.3 手写深拷贝"></a>1.3 手写深拷贝</h4><p>这个题一定要会啊！笔者面试过程中疯狂被问到！</p>
<p>文章推荐：<a href="https://juejin.cn/post/6844903929705136141" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903929705136141">如何写出一个惊艳面试官的深拷贝?</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>obj 要拷贝的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Map&#125;</span> </span>map 用于存储循环引用对象的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj = &#123;&#125;, map = new Map(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (map.get(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 初始化返回结果</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ||</span><br><span class="line">    <span class="comment">// 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此</span></span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString(obj) === <span class="string">"[object Array]"</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    result = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 防止循环引用</span></span><br><span class="line">  map.set(obj, result);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 保证 key 不是原型属性</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 递归调用</span></span><br><span class="line">      result[key] = deepClone(obj[key], map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-根据-0-1-0-2-0-3，讲讲-IEEE-754-，如何让其相等？"><a href="#1-4-根据-0-1-0-2-0-3，讲讲-IEEE-754-，如何让其相等？" class="headerlink" title="1.4 根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？"></a>1.4 根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？</h4><p>建议先阅读这篇文章了解 IEEE 754 ：<a href="https://juejin.cn/post/6940405970954616839" target="_blank" rel="noopener" title="https://juejin.cn/post/6940405970954616839">硬核基础二进制篇（一）0.1 + 0.2 != 0.3 和 IEEE-754 标准</a>。<br>再阅读这篇文章了解如何运算：<a href="https://juejin.cn/post/6844903680362151950" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903680362151950">0.1 + 0.2 不等于 0.3？为什么 JavaScript 有这种“骚”操作？</a>。</p>
<p>原因总结：</p>
<ul>
<li><code>进制转换</code> ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。</li>
<li><code>对阶运算</code> ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（<code>0舍1入</code>），尾数位移时可能会发生数丢失的情况，影响精度。</li>
</ul>
<p>解决办法：</p>
<ol>
<li>转为整数（大数）运算。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> maxLen = <span class="built_in">Math</span>.max(</span><br><span class="line">    a.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length,</span><br><span class="line">    b.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> base = <span class="number">10</span> ** maxLen;</span><br><span class="line">  <span class="keyword">const</span> bigA = BigInt(base * a);</span><br><span class="line">  <span class="keyword">const</span> bigB = BigInt(base * b);</span><br><span class="line">  <span class="keyword">const</span> bigRes = (bigA + bigB) / BigInt(base); <span class="comment">// 如果是 (1n + 2n) / 10n 是等于 0n的。。。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Number</span>(bigRes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里代码是有问题的，因为最后计算 <code>bigRes</code> 的大数相除（即 <code>/</code>）是会把小数部分截掉的，所以我很疑惑为什么网络上很多文章都说可以通过<strong>先转为整数运算再除回去，为了防止转为的整数超出 js 表示范围，还可以运用到 ES6 新增的大数类型，我真的很疑惑，希望有好心人能解答下。</strong></p>
<ol start="2">
<li>使用 <code>Number.EPSILON</code> 误差范围。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a - b) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEqual(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Number.EPSILON</code> 的实质是一个可以接受的最小误差范围，一般来说为 <code>Math.pow(2, -52)</code> 。</p>
<ol start="3">
<li>转成字符串，对字符串做加法运算。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串数字相加</span></span><br><span class="line"><span class="keyword">var</span> addStrings = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = num1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> j = num2.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = i &gt;= <span class="number">0</span> ? <span class="built_in">Number</span>(num1[i]) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> n2 = j &gt;= <span class="number">0</span> ? <span class="built_in">Number</span>(num2[j]) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> sum = n1 + n2 + carry;</span><br><span class="line">    res.unshift(sum % <span class="number">10</span>);</span><br><span class="line">    carry = <span class="built_in">Math</span>.floor(sum / <span class="number">10</span>);</span><br><span class="line">    i--;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">    res.unshift(carry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">""</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">a, b, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [intStr1, deciStr1] = a.toString().split(<span class="string">"."</span>);</span><br><span class="line">  <span class="keyword">const</span> [intStr2, deciStr2] = b.toString().split(<span class="string">"."</span>);</span><br><span class="line">  <span class="keyword">const</span> inteSum = addStrings(intStr1, intStr2); <span class="comment">// 获取整数相加部分</span></span><br><span class="line">  <span class="keyword">const</span> deciSum = addStrings(deciStr1, deciStr2); <span class="comment">// 获取小数相加部分</span></span><br><span class="line">  <span class="keyword">return</span> inteSum + <span class="string">"."</span> + deciSum === <span class="built_in">String</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEqual(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这是 leetcode 上一道原题：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fadd-strings%2F" title="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a>。区别在于原题没有考虑小数，但是也是很简单的，我们分为两个部分计算就行。</p>
<h3 id="2、-原型和原型链"><a href="#2、-原型和原型链" class="headerlink" title="2、 原型和原型链"></a>2、 原型和原型链</h3><p>可以说这部分每家面试官都会问了。。首先理解的话，其实一张图即可，一段代码即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>

<p>千万别畏惧下面这张图，特别有用，一定要搞懂，熟到提笔就能默画出来。<br><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a61ca07672a45d3aecf382100cc9719~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>总结：</p>
<ul>
<li>原型：每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性，其实就是 <code>prototype</code> 对象。</li>
<li>原型链：由相互关联的原型组成的<strong>链状结构</strong>就是原型链。</li>
</ul>
<p>先说出总结的话，再举例子说明如何顺着原型链找到某个属性。</p>
<p>推荐的阅读：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2Fblog%2Fissues%2F2" title="https://github.com/mqyqingfeng/blog/issues/2">JavaScript 深入之从原型到原型链</a> 掌握基本概念，再阅读这篇文章<a href="https://juejin.cn/post/6844903989088092174" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903989088092174">轻松理解 JS 原型原型链</a>加深上图的印象。</p>
<h3 id="3、-作用域与作用域链"><a href="#3、-作用域与作用域链" class="headerlink" title="3、 作用域与作用域链"></a>3、 作用域与作用域链</h3><ul>
<li>作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。换句话说，作用域决定了代码区块中变量和其他资源的可见性。（全局作用域、函数作用域、块级作用域）</li>
<li>作用域链：从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。（由多个执行上下文的<strong>变量对象</strong>构成的链表就叫做作用域链，学习下面的内容之后再考虑这句话）</li>
</ul>
<p><strong>需要注意的是，js 采用的是静态作用域，所以函数的作用域在函数定义时就确定了。</strong></p>
<p>推荐阅读：先阅读<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F3" title="https://github.com/mqyqingfeng/Blog/issues/3">JavaScript 深入之词法作用域和动态作用域</a>，再阅读<a href="https://juejin.cn/post/6844903797135769614" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903797135769614">深入理解 JavaScript 作用域和作用域链</a>。</p>
<h3 id="4、-执行上下文"><a href="#4、-执行上下文" class="headerlink" title="4、 执行上下文"></a>4、 执行上下文</h3><p>这部分一定要按顺序连续读这几篇文章，必须多读几遍：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F4" title="https://github.com/mqyqingfeng/Blog/issues/4">JavaScript 深入之执行上下文栈</a>；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F5" title="https://github.com/mqyqingfeng/Blog/issues/5">JavaScript 深入之变量对象</a>；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F6" title="https://github.com/mqyqingfeng/Blog/issues/6">JavaScript 深入之作用域链</a>；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F8" title="https://github.com/mqyqingfeng/Blog/issues/8">JavaScript 深入之执行上下文</a>。</li>
</ul>
<p>总结：当 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象（Variable object，VO）；</li>
<li>作用域链（Scope chain）；</li>
<li>this。（关于 this 指向问题，在上面推荐的深入系列也有讲从 ES 规范讲的，但是实在是难懂，对于应付面试来说以下这篇阮一峰的文章应该就可以了：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2018%2F06%2Fjavascript-this.html" title="https://www.ruanyifeng.com/blog/2018/06/javascript-this.html">JavaScript 的 this 原理</a>）</li>
</ul>
<h3 id="5、-闭包"><a href="#5、-闭包" class="headerlink" title="5、 闭包"></a>5、 闭包</h3><p>根据 MDN 中文的定义，闭包的定义如下：</p>
<blockquote>
<p>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。</p>
</blockquote>
<p>也可以这样说：</p>
<blockquote>
<p>闭包是指那些能够访问自由变量的函数。<br>自由变量是指在函数中使用的，但既不是<strong>函数参数</strong>也不是<strong>函数的局部变量</strong>的 <strong>变量</strong> 。<br>闭包 = 函数 + 函数能够访问的自由变量。</p>
</blockquote>
<p>在经过上一小节“执行上下文”的学习，再来阅读这篇文章：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F9" title="https://github.com/mqyqingfeng/Blog/issues/9">JavaScript 深入之闭包</a>，你会对闭包的实质有一定的了解。在回答时，我们这样答：</p>
<p>在某个内部函数的执行上下文创建时，会将父级函数的<strong>活动对象</strong>加到内部函数的 <code>[[scope]]</code> 中，形成作用域链，所以即使父级函数的执行上下文销毁（即执行上下文栈弹出父级函数的执行上下文），但是因为其<strong>活动对象</strong>还是实际存储在内存中可被内部函数访问到的，从而实现了闭包。</p>
<p>闭包应用：<br>函数作为参数被传递：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">200</span>;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(fn); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>函数作为返回值被返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = create();</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">200</span>;</span><br><span class="line">fn(); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p><strong>闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方。</strong></p>
<p>应用实例：比如缓存工具，隐藏数据，只提供 API 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCache</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123;&#125;; <span class="comment">// 闭包中被隐藏的数据，不被外界访问</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">set</span>: function (key, val) &#123;</span><br><span class="line">      data[key] = val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>: function (key) &#123;</span><br><span class="line">      <span class="keyword">return</span> data[key];</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = createCache();</span><br><span class="line">c.set(<span class="string">"a"</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c.get(<span class="string">"a"</span>)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<h3 id="6、-call、apply、bind-实现"><a href="#6、-call、apply、bind-实现" class="headerlink" title="6、 call、apply、bind 实现"></a>6、 call、apply、bind 实现</h3><p>这部分实现还是要知道的，就算工作中不会自己手写，但是说不准面试官就是要问，知道点原理也好，可以扩宽我们写代码的思路。</p>
<p><strong>call</strong></p>
<blockquote>
<p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="string">"vortesnail"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj); <span class="comment">// vortesnail</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>call</code> 方法我们做到了以下两点：</p>
<ul>
<li><code>call</code> 改变了 this 的指向，指向到 <code>obj</code> 。</li>
<li><code>fn</code> 函数执行了。</li>
</ul>
<p>那么如果我们自己写 <code>call</code> 方法的话，可以怎么做呢？我们先考虑改造 <code>obj</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="string">"vortesnail"</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.fn(); <span class="comment">// vortesnail</span></span><br></pre></td></tr></table></figure>

<p>这时候 this 就指向了 <code>obj</code> ，但是这样做我们手动给 <code>obj</code> 增加了一个 <code>fn</code> 属性，这显然是不行的，不用担心，我们执行完再使用对象属性的删除方法（delete）不就行了？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.fn = fn;</span><br><span class="line">obj.fn();</span><br><span class="line"><span class="keyword">delete</span> obj.fn;</span><br></pre></td></tr></table></figure>

<p>根据这个思路，我们就可以写出来了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Type error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 首先获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果没有传就设置为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 将被调用的方法设置为 context 的属性</span></span><br><span class="line">  <span class="comment">// this 即为我们要调用的方法</span></span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 执行要被调用的方法</span></span><br><span class="line">  result = context.fn(...args);</span><br><span class="line">  <span class="comment">// 删除手动增加的属性方法</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="comment">// 将执行结果返回</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>apply</strong></p>
<p>我们会了 <code>call</code> 的实现之后，<code>apply</code> 就变得很简单了，他们没有任何区别，除了传参方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Type error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 与上面代码相比，我们使用 Symbol 来保证属性唯一</span></span><br><span class="line">  <span class="comment">// 也就是保证不会重写用户自己原来定义在 context 中的同名属性</span></span><br><span class="line">  <span class="keyword">const</span> fnSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fnSymbol] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 执行要被调用的方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context[fnSymbol](...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context[fnSymbol]();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context[fnSymbol];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>bind</strong></p>
<p><code>bind</code> 返回的是一个函数，这个地方可以详细阅读这篇文章，讲的非常清楚：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F81" title="https://github.com/sisterAn/JavaScript-Algorithms/issues/81">解析 bind 原理，并手写 bind 实现</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Type error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(</span><br><span class="line">      <span class="keyword">this</span> <span class="keyword">instanceof</span> Fn ? <span class="keyword">this</span> : context,</span><br><span class="line">      <span class="comment">// 当前的这个 arguments 是指 Fn 的参数</span></span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7、-new-实现"><a href="#7、-new-实现" class="headerlink" title="7、 new 实现"></a>7、 new 实现</h3><ol>
<li>首先创一个新的空对象。</li>
<li>根据原型链，设置空对象的 <code>__proto__</code> 为构造函数的 <code>prototype</code> 。</li>
<li>构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</li>
<li>判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.__proto__ = context.prototype;</span><br><span class="line">  <span class="keyword">const</span> res = context.apply(obj, [...arguments].slice(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">"object"</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、-异步"><a href="#8、-异步" class="headerlink" title="8、 异步"></a>8、 异步</h3><p>这部分着重要理解 Promise、async awiat、event loop 等。</p>
<h4 id="8-1-event-loop、宏任务和微任务"><a href="#8-1-event-loop、宏任务和微任务" class="headerlink" title="8.1 event loop、宏任务和微任务"></a>8.1 event loop、宏任务和微任务</h4><p>首先推荐一个可以在线看代码流程的网站：<a href="https://link.juejin.cn?target=http%3A%2F%2Flatentflip.com%2Floupe%2F%3Fcode%3DJC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%253D" title="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">loupe</a>。<br>然后看下这个视频学习下：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1oV411k7XY%2F%3Fspm_id_from%3D333.788.recommend_more_video.-1" title="https://www.bilibili.com/video/BV1oV411k7XY/?spm_id_from=333.788.recommend_more_video.-1">到底什么是 Event Loop 呢？</a></p>
<p>简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"cb"</span>); <span class="comment">// cb 即 callback</span></span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Bye"</span>);</span><br></pre></td></tr></table></figure>

<p>它的执行过程是这样的：<br><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e15fc609aa84eac973c5b8ff163c11c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="屏幕录制 2021-07-19 15.01.09.gif"><br>Web APIs 会创建对应的线程，比如 <code>setTimeout</code> 会创建定时器线程，<code>ajax</code> 请求会创建 http 线程。。。这是由 js 的运行环境决定的，比如浏览器。</p>
<p>看完上面的视频之后，至少大家画 Event Loop 的图讲解不是啥问题了，但是涉及到<strong>宏任务</strong>和 <strong>微任务</strong> ，我们还得拜读一下这篇文章：<a href="https://juejin.cn/post/6844903512845860872" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903512845860872">这一次，彻底弄懂 JavaScript 执行机制</a>。如果意犹未尽，不如再读下这篇非常详细带有大量动图的文章：<a href="https://juejin.cn/post/6969028296893792286#comment" target="_blank" rel="noopener" title="https://juejin.cn/post/6969028296893792286#comment">做一些动图，学习一下 EventLoop</a>。想了解事件循环和页面渲染之间关系的又可以再阅读这篇文章：<a href="https://juejin.cn/post/6844904165462769678" target="_blank" rel="noopener" title="https://juejin.cn/post/6844904165462769678">深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）</a>。</p>
<p> <strong>注意：1.Call Stack 调用栈空闲 -&gt; 2.尝试 DOM 渲染 -&gt; 触发 Event loop</strong> 。</p>
<ul>
<li>每次 Call Stack 清空（即每次轮询结束），即同步任务执行完。</li>
<li>都是 DOM 重新渲染的机会，DOM 结构有改变则重新渲染。</li>
<li>然后再去触发下一次 Event loop。</li>
</ul>
<p>宏任务：setTimeout，setInterval，Ajax，DOM 事件。<br>微任务：Promise async/await。</p>
<p>两者区别：</p>
<ul>
<li>宏任务：DOM 渲染后触发，如 <code>setTimeout</code> 、<code>setInterval</code> 、<code>DOM 事件</code> 、<code>script</code> 。</li>
<li>微任务：DOM 渲染前触发，如 <code>Promise.then</code> 、<code>MutationObserver</code> 、Node 环境下的 <code>process.nextTick</code> 。</li>
</ul>
<p><strong>从 event loop 解释，为何微任务执行更早？</strong></p>
<ul>
<li>微任务是 ES6 语法规定的（被压入 micro task queue）。</li>
<li>宏任务是由浏览器规定的（通过 Web APIs 压入 Callback queue）。</li>
<li>宏任务执行时间一般比较长。</li>
<li>每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的。</li>
</ul>
<h4 id="8-2-Promise"><a href="#8-2-Promise" class="headerlink" title="8.2 Promise"></a>8.2 Promise</h4><p>关于这一块儿没什么好说的，最好是实现一遍 Promise A+ 规范，多少有点印象，当然面试官也不会叫你默写一个完整的出来，但是你起码要知道实现原理。</p>
<blockquote>
<p>关于 Promise 的所有使用方式，可参照这篇文章：<a href="https://link.juejin.cn?target=https%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise" title="https://es6.ruanyifeng.com/#docs/promise">ECMAScript 6 入门 - Promise 对象</a>。<br>手写 Promise 源码的解析文章，可阅读此篇文章：<a href="https://juejin.cn/post/6945319439772434469#heading-0" target="_blank" rel="noopener" title="https://juejin.cn/post/6945319439772434469#heading-0">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a>。<br>关于 Promise 的面试题，可参考这篇文章：<a href="https://juejin.cn/post/6844904077537574919" target="_blank" rel="noopener" title="https://juejin.cn/post/6844904077537574919">要就来 45 道 Promise 面试题一次爽到底</a>。</p>
</blockquote>
<p>实现一个 Promise.all：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 参数可以不是数组，但必须具有 Iterator 接口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> promises[<span class="built_in">Symbol</span>.iterator] !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      reject(<span class="string">"Type error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve([]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = [];</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">const</span> len = promises.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//考虑到 promises[i] 可能是 thenable 对象也可能是普通值</span></span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i])</span><br><span class="line">          .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            res[i] = data;</span><br><span class="line">            <span class="keyword">if</span> (++count === len) &#123;</span><br><span class="line">              resolve(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="8-3-async-await-和-Promise-的关系"><a href="#8-3-async-await-和-Promise-的关系" class="headerlink" title="8.3 async/await 和 Promise 的关系"></a>8.3 async/await 和 Promise 的关系</h4><ul>
<li>async/await 是消灭异步回调的终极武器。</li>
<li>但和 Promise 并不互斥，反而，两者相辅相成。</li>
<li>执行 async 函数，返回的一定是 Promise 对象。</li>
<li>await 相当于 Promise 的 then。</li>
<li>tru…catch 可捕获异常，代替了 Promise 的 catch。</li>
</ul>
<h3 id="9、-浏览器的垃圾回收机制"><a href="#9、-浏览器的垃圾回收机制" class="headerlink" title="9、 浏览器的垃圾回收机制"></a>9、 浏览器的垃圾回收机制</h3><p>这里看这篇文章即可：<a href="https://juejin.cn/post/6981588276356317214" target="_blank" rel="noopener" title="https://juejin.cn/post/6981588276356317214">「硬核 JS」你真的了解垃圾回收机制吗</a>。</p>
<p>总结一下：</p>
<p>有两种垃圾回收策略：</p>
<ul>
<li><strong>标记清除</strong> ：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。</li>
<li><strong>引用计数</strong> ：它把<strong>对象是否不再需要</strong>简化定义为 <strong>对象有没有其他对象引用到它</strong> 。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。</li>
</ul>
<p>标记清除的缺点：</p>
<ul>
<li><strong>内存碎片化</strong> ，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。</li>
<li><strong>分配速度慢</strong> ，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。</li>
</ul>
<p>解决以上的缺点可以使用 *<em>标记整理（Mark-Compact）算法 *</em>，标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）<br><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb543f2fdc634e29add495b8f2ff048f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>引用计数的缺点：</p>
<ul>
<li>需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。</li>
<li>解决不了循环引用导致的无法回收问题。</li>
</ul>
<p>V8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化。</p>
<ul>
<li>针对新生区采用并行回收。</li>
<li>针对老生区采用增量标记与惰性回收。</li>
</ul>
<h3 id="10、-实现一个-EventMitter-类"><a href="#10、-实现一个-EventMitter-类" class="headerlink" title="10、 实现一个 EventMitter 类"></a>10、 实现一个 EventMitter 类</h3><p>EventMitter 就是发布订阅模式的典型应用：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> EventEmitter &#123;</span><br><span class="line">  <span class="keyword">private</span> _events: Record&lt;<span class="built_in">string</span>, <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(evt: <span class="built_in">string</span>, ...args: <span class="built_in">any</span>[]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._events[evt]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fns = [...this._events[evt]];</span><br><span class="line">    fns.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(evt: <span class="built_in">string</span>, fn: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"The evet-triggered callback must be a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._events[evt]) &#123;</span><br><span class="line">      <span class="keyword">this</span>._events[evt] = [fn];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._events[evt].push(fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  once(evt: <span class="built_in">string</span>, fn: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> execFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">this</span>.off(evt, execFn);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.on(evt, execFn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off(evt: <span class="built_in">string</span>, fn?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._events[evt]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      <span class="keyword">this</span>._events[evt] &amp;&amp; (<span class="keyword">this</span>._events[evt].length = <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cb;</span><br><span class="line">    <span class="keyword">const</span> cbLen = <span class="keyword">this</span>._events[evt].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbLen; i++) &#123;</span><br><span class="line">      cb = <span class="keyword">this</span>._events[evt][i];</span><br><span class="line">      <span class="keyword">if</span> (cb === fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>._events[evt].splice(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeAllListeners(evt?: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (evt) &#123;</span><br><span class="line">      <span class="keyword">this</span>._events[evt] &amp;&amp; (<span class="keyword">this</span>._events[evt].length = <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、web-存储"><a href="#四、web-存储" class="headerlink" title="四、web 存储"></a>四、web 存储</h2><p>要掌握 cookie，localStorage 和 sessionStorage。</p>
<h3 id="1、cookie"><a href="#1、cookie" class="headerlink" title="1、cookie"></a>1、cookie</h3><ul>
<li>本身用于浏览器和 server 通讯。</li>
<li>被“借用”到本地存储来的。</li>
<li>可用 document.cookie = ‘…’ 来修改。</li>
</ul>
<p>其缺点：</p>
<ul>
<li>存储大小限制为 4KB。</li>
<li>http 请求时需要发送到服务端，增加请求数量。</li>
<li>只能用 document.cookie = ‘…’ 来修改，太过简陋。</li>
</ul>
<h3 id="2、localStorage-和-sessionStorage"><a href="#2、localStorage-和-sessionStorage" class="headerlink" title="2、localStorage 和 sessionStorage"></a>2、localStorage 和 sessionStorage</h3><ul>
<li>HTML5 专门为存储来设计的，最大可存 5M。</li>
<li>API 简单易用， setItem getItem。</li>
<li>不会随着 http 请求被发送到服务端。</li>
</ul>
<p>它们的区别：</p>
<ul>
<li>localStorage 数据会永久存储，除非代码删除或手动删除。</li>
<li>sessionStorage 数据只存在于当前会话，浏览器关闭则清空。</li>
<li>一般用 localStorage 会多一些。</li>
</ul>
<h2 id="五、Http"><a href="#五、Http" class="headerlink" title="五、Http"></a>五、Http</h2><p>前端工程师做出网页，需要通过网络请求向后端获取数据，因此 http 协议是前端面试的必考内容。</p>
<h3 id="1、http-状态码"><a href="#1、http-状态码" class="headerlink" title="1、http 状态码"></a>1、http 状态码</h3><h4 id="1-1-状态码分类"><a href="#1-1-状态码分类" class="headerlink" title="1.1 状态码分类"></a>1.1 状态码分类</h4><ul>
<li>1xx - 服务器收到请求。</li>
<li>2xx - 请求成功，如 200。</li>
<li>3xx - 重定向，如 302。</li>
<li>4xx - 客户端错误，如 404。</li>
<li>5xx - 服务端错误，如 500。</li>
</ul>
<h4 id="1-2-常见状态码"><a href="#1-2-常见状态码" class="headerlink" title="1.2 常见状态码"></a>1.2 常见状态码</h4><ul>
<li>200 - 成功。</li>
<li>301 - 永久重定向（配合 location，浏览器自动处理）。</li>
<li>302 - 临时重定向（配合 location，浏览器自动处理）。</li>
<li>304 - 资源未被修改。</li>
<li>403 - 没权限。</li>
<li>404 - 资源未找到。</li>
<li>500 - 服务器错误。</li>
<li>504 - 网关超时。</li>
</ul>
<h4 id="1-3-关于协议和规范"><a href="#1-3-关于协议和规范" class="headerlink" title="1.3 关于协议和规范"></a>1.3 关于协议和规范</h4><ul>
<li>状态码都是约定出来的。</li>
<li>要求大家都跟着执行。</li>
<li>不要违反规范，例如 IE 浏览器。</li>
</ul>
<h3 id="2、http-缓存"><a href="#2、http-缓存" class="headerlink" title="2、http 缓存"></a>2、http 缓存</h3><ul>
<li>关于缓存的介绍。</li>
<li>http 缓存策略（强制缓存 + 协商缓存）。</li>
<li>刷新操作方式，对缓存的影响。</li>
</ul>
<h4 id="4-1-关于缓存"><a href="#4-1-关于缓存" class="headerlink" title="4.1 关于缓存"></a>4.1 关于缓存</h4><p>什么是缓存？<br>把一些不需要重新获取的内容再重新获取一次</p>
<p>为什么需要缓存？<br>网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。</p>
<p>哪些资源可以被缓存？<br>静态资源，比如 js css img。</p>
<h4 id="4-2-强制缓存"><a href="#4-2-强制缓存" class="headerlink" title="4.2 强制缓存"></a>4.2 强制缓存</h4><p><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ff1ec224244427ba9f15abecbd668fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片 1.png"></p>
<p>Cache-Control：</p>
<ul>
<li>在 Response Headers 中。</li>
<li>控制强制缓存的逻辑。</li>
<li>例如 Cache-Control: max-age=3153600（单位是秒）</li>
</ul>
<p>Cache-Control 有哪些值：</p>
<ul>
<li>max-age：缓存最大过期时间。</li>
<li>no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。</li>
<li>no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。</li>
</ul>
<h4 id="4-3-协商缓存（对比缓存）"><a href="#4-3-协商缓存（对比缓存）" class="headerlink" title="4.3 协商缓存（对比缓存）"></a>4.3 协商缓存（对比缓存）</h4><ul>
<li>服务端缓存策略。</li>
<li>服务端判断客户端资源，是否和服务端资源一样。</li>
<li>一致则返回 304，否则返回 200 和最新的资源。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56e265f46c80430fbf4673878a27bfc9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片 2.png"><br>资源标识：</p>
<ul>
<li>在 Response Headers 中，有两种。</li>
<li>Last-Modified：资源的最后修改时间。</li>
<li>Etag：资源的唯一标识（一个字符串，类似于人类的指纹）。</li>
</ul>
<p><strong>Last-Modified：</strong><br><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c4f44afeb73464295e9878d2c47b024~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片 3.png"><br>服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304<br>，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。</p>
<p><strong>Etag：</strong><br><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e35285a8d23a4a4380676aeb681e815d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片 4.png"><br>其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。</p>
<p><strong>两者比较：</strong></p>
<ul>
<li>优先使用 Etag。</li>
<li>Last-Modified 只能精确到秒级。</li>
<li>如果资源被重复生成，而内容不变，则 Etag 更精确。</li>
</ul>
<h4 id="4-4-综述"><a href="#4-4-综述" class="headerlink" title="4.4 综述"></a>4.4 综述</h4><p><img src= "/img/loading.gif" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b74c746d1459403382fd0bbc1d96aeca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片 5.png"></p>
<h4 id="4-4-三种刷新操作对-http-缓存的影响"><a href="#4-4-三种刷新操作对-http-缓存的影响" class="headerlink" title="4.4 三种刷新操作对 http 缓存的影响"></a>4.4 三种刷新操作对 http 缓存的影响</h4><ul>
<li>正常操作：地址栏输入 url，跳转链接，前进后退等。</li>
<li>手动刷新：f5，点击刷新按钮，右键菜单刷新。</li>
<li>强制刷新：ctrl + f5，shift+command+r。</li>
</ul>
<p><strong>正常操作：强制缓存有效，协商缓存有效。</strong><br><strong>手动刷新：强制缓存失效，协商缓存有效。</strong><br><strong>强制刷新：强制缓存失效，协商缓存失效。</strong></p>
<h3 id="3-面试"><a href="#3-面试" class="headerlink" title="3. 面试"></a>3. 面试</h3><p> <strong>对于更多面试中可能出现的问题，我还是建议精读这篇三元的文章：</strong> <a href="https://juejin.cn/post/6844904100035821575" target="_blank" rel="noopener" title="https://juejin.cn/post/6844904100035821575">HTTP 灵魂之问，巩固你的 HTTP 知识体系</a>。</p>
<p>比如会被经常问到的：<br>GET 和 POST 的区别。</p>
<ul>
<li>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li>
<li>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li>
<li>从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li>
<li>从<strong>幂等性</strong>的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)</li>
<li>从 <strong>TCP</strong> 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</li>
</ul>
<p>HTTP/2 有哪些改进？（很大可能问原理）</p>
<ul>
<li>头部压缩。</li>
<li>多路复用。</li>
<li>服务器推送。</li>
</ul>
<p>关于 HTTPS 的一些原理，可以阅读这篇文章：<a href="https://juejin.cn/post/6844904038509576199" target="_blank" rel="noopener" title="https://juejin.cn/post/6844904038509576199">这一次，彻底理解 https 原理</a>。接着你可以观看这个视频进行更进一步的学习：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1XL411b7KZ%3Fp%3D1" title="https://www.bilibili.com/video/BV1XL411b7KZ?p=1">HTTPS 底层原理，面试官直接下跪，唱征服！</a></p>
<p>关于<strong>跨域</strong>问题，大部分文章都是理论性比较强，还不如读这篇文章，<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F149734572%3Ffrom_voters_page%3Dtrue" title="https://zhuanlan.zhihu.com/p/149734572?from_voters_page=true">聊聊跨域的原理与解决方法</a>，讲的非常清晰，我个人觉得对付面试就是先知道使用流程，把这个流程能自己说出来，然后再讲下原理即可。</p>
<h2 id="六、vue相关"><a href="#六、vue相关" class="headerlink" title="六、vue相关"></a>六、vue相关</h2><p><a href="https://juejin.cn/post/6919373017218809864" target="_blank" rel="noopener">高频前端面试题汇总之Vue篇（上）</a></p>
<p><a href="https://juejin.cn/post/6964779204462247950/" target="_blank" rel="noopener">高频前端面试题汇总之Vue篇（下）</a></p>
<h2 id="七、webpack"><a href="#七、webpack" class="headerlink" title="七、webpack"></a>七、webpack</h2><p>原理初探：<a href="https://juejin.cn/post/6943468761575849992" target="_blank" rel="noopener" title="https://juejin.cn/post/6943468761575849992">当面试官问 Webpack 的时候他想知道什么</a></p>
<p>简易实现：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCosen95%2Fblog%2Fissues%2F48" title="https://github.com/Cosen95/blog/issues/48">面试官：webpack 原理都不会</a>，<a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000039231950" title="https://segmentfault.com/a/1190000039231950">手写一个 webpack，看看 AST 怎么用</a></p>
<p>加料：<a href="https://juejin.cn/post/6844903520378814471" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903520378814471">简单易懂的 webpack 打包后 JS 的运行过程</a>，<a href="https://juejin.cn/post/6888936770692448270" target="_blank" rel="noopener" title="https://juejin.cn/post/6888936770692448270">Webpack 手写 loader 和 plugin</a></p>
<p>热更新原理：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F30669007" title="https://zhuanlan.zhihu.com/p/30669007">Webpack HMR 原理解析</a></p>
<p>面试题：<a href="https://juejin.cn/post/6844904094281236487" target="_blank" rel="noopener" title="https://juejin.cn/post/6844904094281236487">「吐血整理」再来一打 Webpack 面试题</a></p>
<p><strong>这里要注意，应该还会考 webpack5 和 4 有哪些区别。</strong></p>
<h2 id="八、模块化"><a href="#八、模块化" class="headerlink" title="八、模块化"></a>八、模块化</h2><p><a href="https://juejin.cn/post/6844903744518389768" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903744518389768">前端模块化详解(完整版)</a> （这里面没有讲 umd）</p>
<p><a href="https://juejin.cn/post/6844903927104667662" target="_blank" rel="noopener" title="https://juejin.cn/post/6844903927104667662">可能是最详细的 UMD 模块入门指南</a></p>
<h2 id="九、性能优化"><a href="#九、性能优化" class="headerlink" title="九、性能优化"></a>九、性能优化</h2><p>代码层面：</p>
<ul>
<li>防抖和节流（resize，scroll，input）。</li>
<li>减少回流（重排）和重绘。</li>
<li>事件委托。</li>
<li>css 放 ，js 脚本放  最底部。</li>
<li>减少 DOM 操作。</li>
<li>按需加载，比如 React 中使用 <code>React.lazy</code> 和 <code>React.Suspense</code> ，通常需要与 webpack 中的 <code>splitChunks</code> 配合。</li>
</ul>
<p>构建方面：</p>
<ul>
<li><strong>压缩代码文件</strong> ，在 webpack 中使用 <code>terser-webpack-plugin</code> 压缩 Javascript 代码；使用 <code>css-minimizer-webpack-plugin</code> 压缩 CSS 代码；使用 <code>html-webpack-plugin</code> 压缩 html 代码。</li>
<li><strong>开启 gzip 压缩</strong> ，webpack 中使用 <code>compression-webpack-plugin</code> ，node 作为服务器也要开启，使用 <code>compression</code>。</li>
<li><strong>常用的第三方库使用 CDN 服务</strong> ，在 webpack 中我们要配置 externals，将比如 React， Vue 这种包不打倒最终生成的文件中。而是采用 CDN 服务。</li>
</ul>
<p>其它：</p>
<ul>
<li>使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。</li>
<li>使用服务端渲染。</li>
<li>图片压缩。</li>
<li>使用 http 缓存，比如服务端的响应中添加 <code>Cache-Control / Expires</code> 。</li>
</ul>
<h2 id="十、常见手写"><a href="#十、常见手写" class="headerlink" title="十、常见手写"></a>十、常见手写</h2><p>以下的内容是上面没有提到的手写，比如 <code>new</code> 、<code>Promise.all</code> 这种上面内容中已经提到了如何写。</p>
<h3 id="1、防抖"><a href="#1、防抖" class="headerlink" title="1、防抖"></a>1、防抖</h3><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F22" title="https://github.com/mqyqingfeng/Blog/issues/22">JavaScript 专题之跟着 underscore 学防抖 </a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、节流"><a href="#2、节流" class="headerlink" title="2、节流"></a>2、节流</h3><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F26" title="https://github.com/mqyqingfeng/Blog/issues/26">JavaScript 专题之跟着 underscore 学节流</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> preTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nowTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt; wait) &#123;</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">      preTime = nowTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、快速排序"><a href="#3、快速排序" class="headerlink" title="3、快速排序"></a>3、快速排序</h3><p>这里对快排思想不太明白的同学可以看下这个讲解的很清晰的视频：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1at411T75o%3Ffrom%3Dsearch%26seid%3D10065750342799523965%26spm_id_from%3D333.337.0.0" title="https://www.bilibili.com/video/BV1at411T75o?from=search&amp;seid=10065750342799523965&amp;spm_id_from=333.337.0.0">快速排序算法</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArray</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  quickSort(<span class="number">0</span>, nums.length - <span class="number">1</span>, nums);</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">start, end, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = sort(start, end, arr);</span><br><span class="line">    quickSort(start, mid - <span class="number">1</span>, arr);</span><br><span class="line">    quickSort(mid + <span class="number">1</span>, end, arr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">start, end, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> base = arr[start];</span><br><span class="line">  <span class="keyword">let</span> left = start;</span><br><span class="line">  <span class="keyword">let</span> right = end;</span><br><span class="line">  <span class="keyword">while</span> (left !== right) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[right] &gt;= base &amp;&amp; right &gt; left) &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = arr[right];</span><br><span class="line">    <span class="keyword">while</span> (arr[left] &lt;= base &amp;&amp; right &gt; left) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[right] = arr[left];</span><br><span class="line">  &#125;</span><br><span class="line">  arr[left] = base;</span><br><span class="line">  <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、instanceof"><a href="#4、instanceof" class="headerlink" title="4、instanceof"></a>4、instanceof</h3><p>这个手写一定要懂原型及原型链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">target, origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">"object"</span> || target === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> origin !== <span class="string">"function"</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"origin must be function"</span>);</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(target); <span class="comment">// 相当于 proto = target.__proto__;</span></span><br><span class="line">  <span class="keyword">while</span> (proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === origin.prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、数组扁平化"><a href="#5、数组扁平化" class="headerlink" title="5、数组扁平化"></a>5、数组扁平化</h3><p>重点，不要觉得用不到就不管，这道题就是考察你对 js 语法的熟练程度以及手写代码的基本能力。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr, depth = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 以下代码还可以简化，不过为了可读性，还是....</span></span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flat(cur, depth - <span class="number">1</span>) : cur);</span><br><span class="line">    &#125;, []);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.slice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、手写-reduce"><a href="#6、手写-reduce" class="headerlink" title="6、手写 reduce"></a>6、手写 reduce</h3><p>先不考虑第二个参数初始值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">this</span>; <span class="comment">//this就是调用reduce方法的数组</span></span><br><span class="line">  <span class="keyword">let</span> total = arr[<span class="number">0</span>]; <span class="comment">// 默认为数组的第一项</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    total = cb(total, arr[i], i, arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑上初始值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span> (<span class="params">cb, initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> total = initialValue || arr[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 有初始值的话从0遍历，否则从1遍历</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = initialValue ? <span class="number">0</span> : <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    total = cb(total, arr[i], i, arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7、带并发的异步调度器-Scheduler"><a href="#7、带并发的异步调度器-Scheduler" class="headerlink" title="7、带并发的异步调度器 Scheduler"></a>7、带并发的异步调度器 Scheduler</h3><p>JS 实现一个带并发限制的异度调度器 Scheduler，保证同时运行的任务最多有两个。完善下面代码中的 Scheduler 类，使得以下程序能正确输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">  add(promiseMaker) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function">(<span class="params">time</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scheduler = <span class="keyword">new</span> Scheduler();</span><br><span class="line"><span class="keyword">const</span> addTask = <span class="function">(<span class="params">time, order</span>) =&gt;</span> &#123;</span><br><span class="line">  scheduler.add(<span class="function"><span class="params">()</span> =&gt;</span> timeout(time).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(order)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">addTask(<span class="number">1000</span>, <span class="string">"1"</span>);</span><br><span class="line">addTask(<span class="number">500</span>, <span class="string">"2"</span>);</span><br><span class="line">addTask(<span class="number">300</span>, <span class="string">"3"</span>);</span><br><span class="line">addTask(<span class="number">400</span>, <span class="string">"4"</span>);</span><br><span class="line"><span class="comment">// output：2 3 1 4</span></span><br><span class="line"><span class="comment">// 一开始，1，2两个任务进入队列。</span></span><br><span class="line"><span class="comment">// 500ms 时，2完成，输出2，任务3入队。</span></span><br><span class="line"><span class="comment">// 800ms 时，3完成，输出3，任务4入队。</span></span><br><span class="line"><span class="comment">// 1000ms 时，1完成，输出1。</span></span><br></pre></td></tr></table></figure>

<p>根据题目，我们只需要操作 <code>Scheduler</code> 类就行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.waitTasks = []; <span class="comment">// 待执行的任务队列</span></span><br><span class="line">    <span class="keyword">this</span>.excutingTasks = []; <span class="comment">// 正在执行的任务队列</span></span><br><span class="line">    <span class="keyword">this</span>.maxExcutingNum = <span class="number">2</span>; <span class="comment">// 允许同时运行的任务数量</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(promiseMaker) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.excutingTasks.length &lt; <span class="keyword">this</span>.maxExcutingNum) &#123;</span><br><span class="line">      <span class="keyword">this</span>.run(promiseMaker);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.waitTasks.push(promiseMaker);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(promiseMaker) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = <span class="keyword">this</span>.excutingTasks.push(promiseMaker);</span><br><span class="line">    <span class="keyword">const</span> index = len - <span class="number">1</span>;</span><br><span class="line">    promiseMaker().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.excutingTasks.splice(index, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.waitTasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.run(<span class="keyword">this</span>.waitTasks.shift());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、去重"><a href="#8、去重" class="headerlink" title="8、去重"></a>8、去重</h3><ul>
<li>利用 ES6 <code>set</code> 关键字：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用 ES5 <code>filter</code> 方法：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十一、其它"><a href="#十一、其它" class="headerlink" title="十一、其它"></a>十一、其它</h2><ol>
<li>requestAnimationFrame（<a href="https://juejin.cn/post/6991297852462858277" target="_blank" rel="noopener" title="https://juejin.cn/post/6991297852462858277">一个神奇的前端动画 API requestAnimationFrame</a>）</li>
<li>如何排查内存泄漏问题，面试官可能会问为什么页面越来越卡顿，直至卡死，怎么定位到产生这种现象的源代码（开发环境）？（<a href="https://juejin.cn/post/6947841638118998029" target="_blank" rel="noopener" title="https://juejin.cn/post/6947841638118998029">一文带你了解如何排查内存泄漏导致的页面卡顿现象</a>）</li>
<li>vite 大火，我复习的时候是去年 9 月份，还没那么火，可能现在的你需要学一学了～</li>
<li>vue3 也一样，如果你是 React 技术栈（就像我之前一样）当我没说。</li>
</ol>
<h2 id="十二、算法"><a href="#十二、算法" class="headerlink" title="十二、算法"></a>十二、算法</h2><p>这部分大家可以点击以下这个仓库，按照仓库中的题目顺序进行刷题，都是我亲自刷过的，排了最适合的顺序：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvortesnail%2Fleetcode" title="https://github.com/vortesnail/leetcode">vortesnail/leetcode</a>。</p>
<p>然后如果大家想看下大厂的算法高频题可以看这个仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fafatcoder%2FLeetcodeTop" title="https://github.com/afatcoder/LeetcodeTop">afatcoder/LeetcodeTop</a>。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Chen cy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.chency.top/posts/42600/">https://www.chency.top/posts/42600/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.chency.top" target="_blank">CCY's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScrip/">JavaScrip</a><a class="post-meta__tags" href="/tags/Css/">Css</a><a class="post-meta__tags" href="/tags/Html/">Html</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/Http/">Http</a></div><div class="post_share"><div class="social-share" data-image="/CDN/wallpaper/cover_4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button" type="button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/CDN/other/1.png" alt="wechat" onclick="window.open('/CDN/other/1.png')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/CDN/other/3.jpg" alt="alipay" onclick="window.open('/CDN/other/3.jpg')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/26266/"><img class="prev-cover" data-src="/CDN/wallpaper/cover_4.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">async/await使用对比</div></div></a></div><div class="next-post pull-right"><a href="/posts/56620/"><img class="next-cover" data-src="/CDN/wallpaper/cover_1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue 特性集合</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/17705/" title="css盒模型及布局"><img class="relatedPosts_cover" data-src="/CDN/wallpaper/3.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-31</div><div class="relatedPosts_title">css盒模型及布局</div></div></a></div><div class="relatedPosts_item"><a href="/posts/26266/" title="async/await使用对比"><img class="relatedPosts_cover" data-src="/CDN/wallpaper/cover_4.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-31</div><div class="relatedPosts_title">async/await使用对比</div></div></a></div><div class="relatedPosts_item"><a href="/posts/61384/" title="Promise实现原理"><img class="relatedPosts_cover" data-src="/CDN/wallpaper/16.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-31</div><div class="relatedPosts_title">Promise实现原理</div></div></a></div><div class="relatedPosts_item"><a href="/posts/59605/" title="RegExp基础语法"><img class="relatedPosts_cover" data-src="/CDN/wallpaper/1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-31</div><div class="relatedPosts_title">RegExp基础语法</div></div></a></div><div class="relatedPosts_item"><a href="/posts/15950/" title="vue样式穿透 ::v-deep的具体使用"><img class="relatedPosts_cover" data-src="/CDN/wallpaper/cover_2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-31</div><div class="relatedPosts_title">vue样式穿透 ::v-deep的具体使用</div></div></a></div><div class="relatedPosts_item"><a href="/posts/56620/" title="Vue 特性集合"><img class="relatedPosts_cover" data-src="/CDN/wallpaper/cover_1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-31</div><div class="relatedPosts_title">Vue 特性集合</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><label><input id="switch-comments-btn" type="checkbox"><span class="slider"></span></label><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div class="comments-items-1" data-name="Valine"><div class="vcomment" id="vcomment"></div><script>function loadvaline () {  
  var requestSetting = function (from,set) {
    var from = from
    var setting = set.split(',').filter(function(item){
    return from.indexOf(item) > -1
    });
    setting = setting.length == 0 ? from :setting;
    return setting
  }

  var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
  var requiredFields = requestSetting(['nick','mail'],'nick,mail')

  function initValine () {
    window.valine = new Valine({
      el:'#vcomment',
      appId: 'lJQjsDGUspQiaqItppf8nrvU-gzGzoHsz',
      appKey: '50hippIeimuu0vqHczrFDF5j',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: guestInfo,
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      requiredFields: requiredFields
    });
  }
  loadScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || false) {
  window.addEventListener('load', loadvaline)
}
else {
  function loadOtherComment () {
    loadvaline()
  }
}</script></div><div class="comments-items-2" data-name="Disqus"><div id="disqus_thread"></div><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://www.chency.top/posts/42600/';
    this.page.identifier = 'posts/42600/';
    this.page.title = 'web学习路线汇总篇';
  };

  var d = document, s = d.createElement('script');
  s.src = 'https://.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
}

if ('Valine' === 'Disqus' || false) {
  window.addEventListener('load', loadDisqus)
}
else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Chen cy</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">我相信我可以，但我一直在路上，所以我有无限的可能！！</div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 4.2.0"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script data-pjax src="/js/chency.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":120,"height":260},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>