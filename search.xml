<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>css清浮动</title>
      <link href="posts/17955/"/>
      <url>posts/17955/</url>
      
        <content type="html"><![CDATA[<p>人们经常谈起清浮动，其实就是解决浮动元素的包含块高度塌陷的问题</p><h2 id="【1】clear-属性"><a href="#【1】clear-属性" class="headerlink" title="【1】clear 属性"></a>【1】clear 属性</h2><p>值: <code>left | right | both | none | inherit</code><br>初始值: none<br>应用于: 块级元素(块级元素指 block 元素，不包括 inline-block 元素)<br>继承性: 无</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left:左侧不允许存在浮动元素</span><br><span class="line">right:右侧不允许存在浮动元素</span><br><span class="line">both:左右两侧不允许存在浮动元素</span><br><span class="line">none:允许左右两侧存在浮动元素</span><br></pre></td></tr></table></figure><ul><li><code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code>&lt;注意&gt;并不是很适用，若包含块为<code>&lt;ul&gt;</code>，则子元素只能为<code>&lt;li&gt;</code>，则在<code>&lt;li&gt;</code>后面添加<code>&lt;div&gt;</code>元素不合适</li><li><code>&lt;br style=&quot;clear:both&quot;&gt;</code>&lt;注意&gt;虽然 clear 属性只应用于块级元素，但在除 IE7-以外的其他浏览器都可以将 clear 属性应用于<code>&lt;br&gt;</code>元素</li><li>为浮动元素的 after 伪元素设置 clear 属性<code>.clear:after{content:&quot;&quot;; display: block; clear: both;}</code></li></ul><h2 id="【2】BFC"><a href="#【2】BFC" class="headerlink" title="【2】BFC"></a>【2】BFC</h2><ul><li><p>1、float: left/right</p></li><li><p>2、position:absolute/fixed</p></li><li><p>3、display:inline-block/table-cell/table-caption/flex</p></li><li><p>4、overflow:hidden/scroll/auto</p></li></ul><p><a href="https://www.cnblogs.com/xiaohuochai/p/5248536.html" target="_blank" rel="noopener">关于 BFC 的详细信息移步至此</a></p><h2 id="【3】IE7"><a href="#【3】IE7" class="headerlink" title="【3】IE7-"></a>【3】IE7-</h2><p>关于 IE7-浏览器有一个其特有的属性 haslayout，当触发包含块的 haslayout 时，浮动元素被 layout 元素自动包含</p><ul><li><p>1、display:inline-block</p></li><li><p>2、height/width:除 auto 外</p></li><li><p>3、float: left/right</p></li><li><p>4、position: absolute</p></li><li><p>5、writing-mode: tb-rl</p></li><li><p>6、zoom: 除 normal 外</p></li></ul><p><a href="https://www.cnblogs.com/xiaohuochai/p/4845314.html" target="_blank" rel="noopener">关于 haslayout 的详细信息移步至此</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装配置git教程</title>
      <link href="posts/37056/"/>
      <url>posts/37056/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步，下载安装git"><a href="#第一步，下载安装git" class="headerlink" title="第一步，下载安装git"></a>第一步，下载安装git</h2><p>打开 <a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a>，下载git对应操作系统的版本。</p><p>所有东西下载慢的话就可以去找镜像！官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/git-for-windows/下载对应的版本即可安装！</a></p><h2 id="第二步，检查git是否安装成功"><a href="#第二步，检查git是否安装成功" class="headerlink" title="第二步，检查git是否安装成功"></a>第二步，检查git是否安装成功</h2><p>打开命令行窗口，在cmd中输入git或git–version。</p><h2 id="第三步，配置User信息（默认已注册github账号）"><a href="#第三步，配置User信息（默认已注册github账号）" class="headerlink" title="第三步，配置User信息（默认已注册github账号）"></a>第三步，配置User信息（默认已注册github账号）</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。</p><p>这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 配置用户名</span><br><span class="line">git config --global user.name &quot;username&quot;    &#x2F;&#x2F;（ &quot;username&quot;是自己的账户名，）</span><br><span class="line"># 配置邮箱</span><br><span class="line">git config --global user.email &quot;username@email.com&quot;     &#x2F;&#x2F;(&quot;username@email.com&quot;注册账号时用的邮箱)</span><br></pre></td></tr></table></figure><p>以上命令执行结束后，可用 git config –global –list 命令查看配置是否OK。</p><h2 id="第四步，设置本机绑定SSH公钥，实现免密码登录"><a href="#第四步，设置本机绑定SSH公钥，实现免密码登录" class="headerlink" title="第四步，设置本机绑定SSH公钥，实现免密码登录"></a>第四步，设置本机绑定SSH公钥，实现免密码登录</h2><p>继续刚才的操作，在命令框中输入以下命令:</p><p><code>ssh-keygen -t rsa</code></p><p>然后连敲三次回车键，结束后去系统盘目录下（一般在 C:Users你的用户名.ssh）(mac: /Users/用户/.ssh）查看是否有。ssh文件夹生成，此文件夹中以下两个文件：</p><p>将ssh文件夹中的公钥（ id_rsa.pub）添加到GitHub管理平台中，在GitHub的个人账户的设置中找到如下界面。title随便起一个，将公钥（ id_rsa.pub）文件中内容复制粘贴到key中，然后点击Ass SSH key就好啦。</p><h2 id="第五步，测试配置是否成功"><a href="#第五步，测试配置是否成功" class="headerlink" title="第五步，测试配置是否成功"></a>第五步，测试配置是否成功</h2><p>在Git Bush命令框（就是刚才配置账号和邮箱的命令框）中继续输入以下命令，回车：</p><p><code>ssh -T git@github.com</code></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-快速排序</title>
      <link href="posts/7837/"/>
      <url>posts/7837/</url>
      
        <content type="html"><![CDATA[<p><strong>快速排序</strong>最常用的排序算法之一。时间复杂度一般为 O(nlog(n)),空间复杂度为O(1)(左右指针交替的原地排序)。</p><a id="more"></a><p>快速排序和<a href="/posts/51816">归并排序</a>一样也使用<a href="">分而治之</a>的方法。</p><h2 id="设置比较函数和交换函数"><a href="#设置比较函数和交换函数" class="headerlink" title="设置比较函数和交换函数"></a>设置比较函数和交换函数</h2><ul><li>自定义一个 compare 函数，命名为 compareFn</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareFn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义一个交换函数，命名为 swap</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array,a,b</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//经典方式</span></span><br><span class="line">  <span class="comment">// const temp = array[a];</span></span><br><span class="line">  <span class="comment">// array[a] = array[b];</span></span><br><span class="line">  <span class="comment">// array[b] = temp;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//ES6 的方式</span></span><br><span class="line">  [array[a],array[b]] = [array[b],array[a]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="划分过程"><a href="#划分过程" class="headerlink" title="划分过程"></a>划分过程</h2><ul><li>随机选取其中一个值或选择中间值做为主元，初始化第一个值为 left 指针，最后一个值为 right 指针</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array, left, right, compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pivot = array[<span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)];</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br></pre></td></tr></table></figure><ul><li>移动 left 指针直到找到比主元大的元素。</li><li>同理，移动 right 指针直到找到一个比主元小的元素。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (compareFn(array[i], pivot) === Compare.LESS_THAN) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (compareFn(array[j], pivot) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>此时当 left 指针索引小于等于 right 指针索引时，进行交换,继续移动指针，重复此过程，并返回最终左指针索引，用于递归函数创建子数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">      swap(array, i, j);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归函数重复对数组进行划分"><a href="#递归函数重复对数组进行划分" class="headerlink" title="递归函数重复对数组进行划分"></a>递归函数重复对数组进行划分</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick</span>(<span class="params">array, left, right, compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line">  <span class="keyword">if</span> (array.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    index = partition(array, left, right, compareFn);</span><br><span class="line">    <span class="keyword">if</span> (left &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">      quick(array, left, index - <span class="number">1</span>, compareFn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; right) &#123;</span><br><span class="line">      quick(array, index, right, compareFn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置主函数调用递归函数"><a href="#设置主函数调用递归函数" class="headerlink" title="设置主函数调用递归函数"></a>设置主函数调用递归函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> quick(array, <span class="number">0</span>, array.length - <span class="number">1</span>, compareFn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScrip </tag>
            
            <tag> 排序 </tag>
            
            <tag> 分而治之 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise实现原理</title>
      <link href="posts/61384/"/>
      <url>posts/61384/</url>
      
        <content type="html"><![CDATA[<p>在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而 Promise 将回调嵌套改为链式调用，增加可读性和可维护性。</p><h2 id="Promise-的调用流程"><a href="#Promise-的调用流程" class="headerlink" title="Promise 的调用流程"></a>Promise 的调用流程</h2><ul><li><code>Promise</code>的构造方法接收一个 executor()，在<code>new Promise()</code>时就立刻执行这个 executor 回调</li><li><code>executor()</code>内部的异步任务被放入宏/微任务队列，等待执行</li><li><code>then()</code>被执行，收集成功/失败回调，放入成功/失败队列</li><li><code>executor()</code>的异步任务被执行，触发<code>resolve/reject</code>，从成功/失败队列中取出回调依次执行</li></ul><h2 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise A+规范"></a>Promise A+规范</h2><p>由于 ES6 的 Promise 实现需要遵循 Promise/A+规范，是规范对 Promise 的状态控制做了要求。Promise/A+的规范比较长，这里只总结两条核心规则：</p><ul><li><code>Promise</code> 本质是一个状态机，且状态只能为以下三种：<code>Pending（等待态）</code>、<code>Fulfilled（执行态）</code>、<code>Rejected（拒绝态）</code>，状态的变更是单向的，只能从 Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆</li><li><code>then</code>方法接收两个可选参数，分别对应状态改变时触发的回调。then 方法返回一个 promise。then 方法可以被同一个 promise 调用多次。</li></ul><h2 id="then-的链式调用"><a href="#then-的链式调用" class="headerlink" title="then 的链式调用"></a>then 的链式调用</h2><p>先举个例子看一下 then 是如何链式调用的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="comment">//then回调中可以return一个Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="comment">//then回调中也可以return一个值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>输出：1 2 3</p><h3 id="如何实现链式调用"><a href="#如何实现链式调用" class="headerlink" title="如何实现链式调用"></a>如何实现链式调用</h3><ul><li>显然<code>then()</code>需要返回一个 Promise，这样才能找到 then 方法，所以我们会把 then 方法的返回值包装成 Promise。</li><li><code>then()</code>的回调需要拿到上一个<code>then()</code>的返回值</li><li><code>then()</code>的回调需要顺序执行，以上面这段代码为例，虽然中间 return 了一个 Promise，但执行顺序仍要保证是 1-&gt;2-&gt;3。我们要等待当前 Promise 状态变更后，再执行下一个 then 收集的回调，这就要求我们对 then 的返回值分类讨论</li></ul><h2 id="值穿透-amp-状态已变更情况"><a href="#值穿透-amp-状态已变更情况" class="headerlink" title="值穿透&amp;状态已变更情况"></a>值穿透&amp;状态已变更情况</h2><ul><li>值穿透：根据规范，如果 then() 接收的参数不是 function，那么我们应该忽略它。如果没有忽略，当 then()回调不为 function 时将会抛出异常，导致链式调用中断</li><li>处理状态为 resolve/reject 的情况：其实我们上边 then() 的写法是对应状态为<code>padding</code>的情况，但是有些时候，resolve/reject 在 then() 之前就被执行（比如<code>Promise.resolve().then()</code>），如果这个时候还把 then()回调 push 进 resolve/reject 的执行队列里，那么回调将不会被执行，因此对于状态已经变为<code>fulfilled</code>或<code>rejected</code>的情况，我们直接执行 then 回调</li></ul><h2 id="兼容同步任务"><a href="#兼容同步任务" class="headerlink" title="兼容同步任务"></a>兼容同步任务</h2><p>完成了 then 的链式调用以后，我们再处理一个前边的细节，然后放出完整代码。上文我们说过，Promise 的执行顺序是 <code>new Promise -&gt; then()收集回调 -&gt; resolve/reject 执行回调</code>，这一顺序是建立在 executor 是异步任务的前提上的，如果 executor 是一个同步任务，那么顺序就会变成 <code>new Promise -&gt; resolve/reject 执行回调 -&gt; then()收集回调</code>，resolve 的执行跑到 then 之前去了，为了兼容这种情况，我们给 resolve/reject 执行回调的操作包一个 setTimeout，让它异步执行。</p><h2 id="结合之前的五步，实现了-Promise-的主要功能"><a href="#结合之前的五步，实现了-Promise-的主要功能" class="headerlink" title="结合之前的五步，实现了 Promise 的主要功能"></a>结合之前的五步，实现了 Promise 的主要功能</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规定的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>._status = PENDING; <span class="comment">// Promise状态</span></span><br><span class="line">    <span class="keyword">this</span>._value = <span class="literal">undefined</span>; <span class="comment">// 储存then回调return的值</span></span><br><span class="line">    <span class="keyword">this</span>._resolveQueue = []; <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">    <span class="keyword">this</span>._rejectQueue = []; <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">    <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span></span><br><span class="line">      <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>; <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">        <span class="keyword">this</span>._status = FULFILLED; <span class="comment">// 变更状态</span></span><br><span class="line">        <span class="keyword">this</span>._value = val; <span class="comment">// 储存当前value</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"</span></span><br><span class="line">        <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>._resolveQueue.length) &#123;</span><br><span class="line">          <span class="keyword">const</span> callback = <span class="keyword">this</span>._resolveQueue.shift();</span><br><span class="line">          callback(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      setTimeout(run);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 实现同resolve</span></span><br><span class="line">    <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>; <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">        <span class="keyword">this</span>._status = REJECTED; <span class="comment">// 变更状态</span></span><br><span class="line">        <span class="keyword">this</span>._value = val; <span class="comment">// 储存当前value</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>._rejectQueue.length) &#123;</span><br><span class="line">          <span class="keyword">const</span> callback = <span class="keyword">this</span>._rejectQueue.shift();</span><br><span class="line">          callback(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      setTimeout(run);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">    executor(_resolve, _reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">    <span class="keyword">typeof</span> resolveFn !== <span class="string">'function'</span> ? <span class="function">(<span class="params">resolveFn = (value</span>) =&gt;</span> value) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">typeof</span> rejectFn !== <span class="string">'function'</span></span><br><span class="line">      ? <span class="function">(<span class="params">rejectFn = (reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? reason.message : reason);</span><br><span class="line">        &#125;)</span><br><span class="line">      : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">      <span class="keyword">const</span> fulfilledFn = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">          <span class="keyword">let</span> x = resolveFn(value);</span><br><span class="line">          <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">          x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// reject同理</span></span><br><span class="line">      <span class="keyword">const</span> rejectedFn = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = rejectFn(error);</span><br><span class="line">          x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>._status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._resolveQueue.push(fulfilledFn);</span><br><span class="line">          <span class="keyword">this</span>._rejectQueue.push(rejectedFn);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilledFn(<span class="keyword">this</span>._value); <span class="comment">// this._value是上一个then回调return的值</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejectedFn(<span class="keyword">this</span>._value);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加几个-Promise-的静态-实例方法"><a href="#添加几个-Promise-的静态-实例方法" class="headerlink" title="添加几个 Promise 的静态/实例方法"></a>添加几个 Promise 的静态/实例方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line">  <span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//finally方法</span></span><br><span class="line">  <span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      value =&gt; MyPromise.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),             <span class="comment">//执行回调,并returnvalue传递给后面的then</span></span><br><span class="line">      reason =&gt; MyPromise.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  <span class="comment">//reject同理</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态的resolve方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value <span class="comment">//根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态的reject方法</span></span><br><span class="line">  <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态的all方法</span></span><br><span class="line">  <span class="keyword">static</span> all(promiseArr) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">        MyPromise.resolve(p).then(</span><br><span class="line">          val =&gt; &#123;</span><br><span class="line">            index++</span><br><span class="line">            result[i] = val</span><br><span class="line">            <span class="keyword">if</span>(index === promiseArr.length) &#123;</span><br><span class="line">              resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态的race方法</span></span><br><span class="line">  <span class="keyword">static</span> race(promiseArr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">        MyPromise.resolve(p).then(  <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">          value =&gt; &#123;</span><br><span class="line">            resolve(value)        <span class="comment">//注意这个resolve是上边new MyPromise的</span></span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScrip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题分页问题</title>
      <link href="posts/65246/"/>
      <url>posts/65246/</url>
      
        <content type="html"><![CDATA[<p>辅助函数 paginator 能够帮助我们插入分页链接，具体参数查看<a href="https://hexo.io/docs/helpers.html#paginator" target="_blank" rel="noopener">https://hexo.io/docs/helpers.html#paginator</a></p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>分页标签显示为 HTML 代码如：<code>&lt;i class=&quot;nexmoefont icon-left&quot;&gt;&lt;/i&gt;</code></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>找到 pagination.ejs 中的 paginator 函数，添加 escape: false 试试，完整代码形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- paginator(&#123;</span><br><span class="line">      prev_text: &#39;&lt;i class&#x3D;&quot;iconfont icon-arrow-left&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">      next_text: &#39;&lt;i class&#x3D;&quot;iconfont icon-arrow-right&quot;&gt;&lt;&#x2F;i&gt;&#39;,</span><br><span class="line">      escape: false</span><br><span class="line">    &#125;) %&gt;</span><br></pre></td></tr></table></figure><p>原文参考：<a href="https://www.zhihu.com/question/370971597/answer/1147674723" target="_blank" rel="noopener">https://www.zhihu.com/question/370971597/answer/1147674723</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-归并排序</title>
      <link href="posts/51816/"/>
      <url>posts/51816/</url>
      
        <content type="html"><![CDATA[<p><strong>归并排序</strong>第一个可以实际使用排序算法之一。时间复杂度为 O(nlog(n)),空间复杂度为 O(n)。</p><a id="more"></a><h2 id="设置比较函数"><a href="#设置比较函数" class="headerlink" title="设置比较函数"></a>设置比较函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareFn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主函数负责用递归法将一个大数组分成多个小数组，并调用辅助函数进行排序、合并"><a href="#主函数负责用递归法将一个大数组分成多个小数组，并调用辅助函数进行排序、合并" class="headerlink" title="主函数负责用递归法将一个大数组分成多个小数组，并调用辅助函数进行排序、合并"></a>主函数负责用递归法将一个大数组分成多个小数组，并调用辅助函数进行排序、合并</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array, compareFn = defaultCompare</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (array.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = array; <span class="comment">// 获取数组长度，参照ES6语法</span></span><br><span class="line">    <span class="keyword">const</span> middle = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> left = mergeSort(array.slice(<span class="number">0</span>, middle), compareFn);</span><br><span class="line">    <span class="keyword">const</span> right = mergeSort(array.slice(middle, length), compareFn);</span><br><span class="line">    array = merge(left, right, compareFn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="merge-函数负责合并小数组来产生大数组，直到回到原始数组"><a href="#merge-函数负责合并小数组来产生大数组，直到回到原始数组" class="headerlink" title="merge 函数负责合并小数组来产生大数组，直到回到原始数组"></a>merge 函数负责合并小数组来产生大数组，直到回到原始数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right, compareFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">    result.push(</span><br><span class="line">      compareFn(left[i], right[j]) === Compare.LESS_THAN</span><br><span class="line">        ? left[i++]</span><br><span class="line">        : right[j++]</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.concat(i &lt; left.length ? left.slice(i) : right.slice(j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScrip </tag>
            
            <tag> 排序 </tag>
            
            <tag> 分而治之 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="posts/520520/"/>
      <url>posts/520520/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="posts/55046/"/>
      <url>posts/55046/</url>
      
        <content type="html"><![CDATA[<p>动态规划方法是将问题分解成相互依赖的子问题来解决的优化技术。</p><a id="more"></a><h2 id="解决问题三步骤"><a href="#解决问题三步骤" class="headerlink" title="解决问题三步骤"></a>解决问题三步骤</h2><ul><li>(1)定义子问题</li><li>(2)实现要反复执行来解决子问题的部分(参考递归方法)</li><li>(3)识别并求解出基线条件</li></ul><h2 id="运用动态规划解决著名问题"><a href="#运用动态规划解决著名问题" class="headerlink" title="运用动态规划解决著名问题"></a>运用动态规划解决著名问题</h2><ul><li><a href="">背包问题</a>：待写</li><li><a href="">最长公共子序列</a>：待写</li><li><a href="">硬币找零</a>：待写</li><li><a href="">矩阵链相乘</a>：待写</li><li><a href="">图的全源最短路径</a>：待写</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScrip </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="posts/60033/"/>
      <url>posts/60033/</url>
      
        <content type="html"><![CDATA[<p><strong>回溯算法</strong>也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><h2 id="用回溯算法解决问题的一般步骤："><a href="#用回溯算法解决问题的一般步骤：" class="headerlink" title="用回溯算法解决问题的一般步骤："></a>用回溯算法解决问题的一般步骤：</h2><ul><li>1、针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</li><li>2、确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。</li><li>3、以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</li></ul><h2 id="BFS-回溯实例"><a href="#BFS-回溯实例" class="headerlink" title="BFS+回溯实例"></a>BFS+回溯实例</h2><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2020/11/13/D9c3AU.md.png" alt="电话号码字母组合"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">digits</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> letterCombinations = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (digits.length == <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> map = &#123;</span><br><span class="line">    <span class="number">2</span>: <span class="string">'abc'</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">'def'</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">'ghi'</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">'jkl'</span>,</span><br><span class="line">    <span class="number">6</span>: <span class="string">'mno'</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">'pqrs'</span>,</span><br><span class="line">    <span class="number">8</span>: <span class="string">'tuv'</span>,</span><br><span class="line">    <span class="number">9</span>: <span class="string">'wxyz'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">curStr, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//设置数组越界后，输出一个解并跳出本次回溯的分支</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; digits.length - <span class="number">1</span>) &#123;</span><br><span class="line">      res.push(curStr);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提取当前i的字符串，并建立分支，进行回溯递归</span></span><br><span class="line">    <span class="keyword">const</span> letters = map[digits[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> l <span class="keyword">of</span> letters) &#123;</span><br><span class="line">      dfs(curStr + l, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(<span class="string">''</span>, <span class="number">0</span>);<span class="comment">//递归入口</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScrip </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法技巧</title>
      <link href="posts/53275/"/>
      <url>posts/53275/</url>
      
        <content type="html"><![CDATA[<p>一个算法设计中的方法不仅可以运用到各种排序、搜索算法中，还是解决多类实际问题的基本逻辑。</p><a id="more"></a><h2 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h2><p>分而治之方法是把问题分解成相互独立的子问题，然后组合他们的答案。具体运用参考<a href="/posts/51816">归并排序</a>和<a href="/posts/7837">快速排序</a></p><ul><li>(1)<strong>分解</strong>原问题为多个子问题</li><li>(2)<strong>解决</strong>子问题，用返回解决子问题的方式的递归算法</li><li>(3)<strong>组合</strong>子问题的解决方式，得到原问题的解</li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><a href="/posts/55046">动态规划</a></li></ul><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul><li><a href="">贪心算法</a></li></ul><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><ul><li><a href="">回溯算法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScrip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的全局对象</title>
      <link href="posts/43529/"/>
      <url>posts/43529/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p><a id="more"></a><h2 id="浏览器中它被命名为-window"><a href="#浏览器中它被命名为-window" class="headerlink" title="浏览器中它被命名为 window"></a>浏览器中它被命名为 window</h2><p>window 及 window 对象上的所有属性都是全局变量。</p><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> env = <span class="string">'Browser'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(env);</span><br><span class="line"><span class="comment">// Browser</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.env);</span><br><span class="line"><span class="comment">// Browser</span></span><br></pre></td></tr></table></figure><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">env = <span class="string">'Browser'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(env);</span><br><span class="line"><span class="comment">// Browser</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.env);</span><br><span class="line"><span class="comment">// Browser</span></span><br></pre></td></tr></table></figure><ul><li>在全局作用域下使用或不使用 var 关键字定义变量都会被附加到 window 对象上成为全局变量</li><li>例 1 和 例 2 中的 env 都是全局变量，打印 env 和 window.env 会得到相同结果</li></ul><h2 id="对-Node-JS-而言是-global"><a href="#对-Node-JS-而言是-global" class="headerlink" title="对 Node.JS 而言是 global"></a>对 Node.JS 而言是 global</h2><p>global 及 global 对象上的所有属性都是全局变量。</p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> env = <span class="string">'Node.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(env);</span><br><span class="line"><span class="comment">// Node.js</span></span><br><span class="line"><span class="built_in">console</span>.log(global.env);</span><br><span class="line"><span class="comment">// Node.js</span></span><br></pre></td></tr></table></figure><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">env = <span class="string">'Node.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(env);</span><br><span class="line"><span class="comment">// Node.js</span></span><br><span class="line"><span class="built_in">console</span>.log(global.env);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li>在 Node.js 中，每个模块都有自己的作用域，在模块的顶层作用域下，使用 var 关键字定义的变量不会被附加到 global 对象上，不使用 var 关键字定义的变量会被附加到 global 对象上成为全局变量</li><li>例 3 中的 env 是全局变量，打印 env 和 global.env 会得到相同结果，例 4 中的 env 不是全局变量，global 对象中不存在 env 属性</li></ul><h2 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h2><p>使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 定义的 JavaScript 浏览器脚本，被认为是个单独的模块，它有自己的顶级作用域，使用 var 关键字定义变量不会被附加到 window 对象上。<br>在 Node.js 的 REPL（Read Eval Print Loop：交互式解释器）中，使用或不使用 var 关键字定义变量都会被附加到 global 对象上成为全局变量。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScrip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Stack</title>
      <link href="posts/12893/"/>
      <url>posts/12893/</url>
      
        <content type="html"><![CDATA[<p>Stack 是一种遵从<strong>后进后出（LIFO）</strong>原则的有序集合。</p><a id="more"></a><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>用 JavaScrip 写一个 Stack 的类，实现栈的常用方法 push、pop 等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items[<span class="keyword">this</span>.count] = element;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count--;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.items[<span class="keyword">this</span>.count];</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.items[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.count; i++) &#123;</span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="keyword">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScrip </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
